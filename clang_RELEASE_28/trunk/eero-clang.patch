Index: include/clang/Frontend/FrontendAction.h
===================================================================
--- include/clang/Frontend/FrontendAction.h	(revision 123041)
+++ include/clang/Frontend/FrontendAction.h	(working copy)
@@ -32,6 +32,7 @@
   IK_CXX,
   IK_ObjC,
   IK_ObjCXX,
+  IK_Eero,  
   IK_PreprocessedC,
   IK_PreprocessedCXX,
   IK_PreprocessedObjC,
Index: include/clang/Basic/LangOptions.h
===================================================================
--- include/clang/Basic/LangOptions.h	(revision 123041)
+++ include/clang/Basic/LangOptions.h	(working copy)
@@ -44,6 +44,8 @@
   unsigned ObjCNonFragileABI : 1;  // Objective-C modern abi enabled
   unsigned ObjCNonFragileABI2 : 1;  // Objective-C enhanced modern abi enabled
 
+  unsigned Eero              : 1;  // Eero (Objective-C 2 dialect) support enabled.
+
   unsigned PascalStrings     : 1;  // Allow Pascal strings
   unsigned WritableStrings   : 1;  // Allow writable strings
   unsigned ConstStrings      : 1;  // Add const qualifier to strings (-Wwrite-strings)
@@ -139,7 +141,7 @@
     Trigraphs = BCPLComment = Bool = DollarIdents = AsmPreprocessor = 0;
     GNUMode = GNUKeywords = ImplicitInt = Digraphs = 0;
     HexFloats = 0;
-    GC = ObjC1 = ObjC2 = ObjCNonFragileABI = ObjCNonFragileABI2 = 0;
+    GC = ObjC1 = ObjC2 = Eero = ObjCNonFragileABI = ObjCNonFragileABI2 = 0;
     NoConstantCFStrings = 0; InlineVisibilityHidden = 0;
     C99 = Microsoft = Borland = CPlusPlus = CPlusPlus0x = 0;
     CXXOperatorNames = PascalStrings = WritableStrings = ConstStrings = 0;
Index: include/clang/Basic/DiagnosticParseKinds.td
===================================================================
--- include/clang/Basic/DiagnosticParseKinds.td	(revision 123041)
+++ include/clang/Basic/DiagnosticParseKinds.td	(working copy)
@@ -251,6 +251,11 @@
   "declaration does not declare a parameter">;
 def err_no_matching_param : Error<"parameter named %0 is missing">;
 
+/// Eero (Objective-C) parser diagnostics
+def err_ambiguous_indentation : Error<"ambiguous indentation">;
+def err_goto_statement_forbidden : Error<"goto statement is forbidden">;
+
+
 /// C++ parser diagnostics
 def err_expected_unqualified_id : Error<
   "expected %select{identifier|unqualified-id}0">;
Index: include/clang/Sema/Scope.h
===================================================================
--- include/clang/Sema/Scope.h	(revision 123041)
+++ include/clang/Sema/Scope.h	(working copy)
@@ -15,6 +15,7 @@
 #define LLVM_CLANG_SEMA_SCOPE_H
 
 #include "llvm/ADT/SmallPtrSet.h"
+#include "llvm/ADT/SmallVector.h"
 
 namespace clang {
 
@@ -122,6 +123,10 @@
   typedef llvm::SmallPtrSet<Decl *, 32> DeclSetTy;
   DeclSetTy DeclsInScope;
 
+  /// List of (ordered) Eero namespace-like prefixes
+  typedef llvm::SmallVector<const char *, 32> PrefixListTy;
+  PrefixListTy PrefixesInScope;
+
   /// Entity - The entity with which this scope is associated. For
   /// example, the entity of a class scope is the class itself, the
   /// entity of a function scope is a function, etc. This field is
@@ -133,7 +138,7 @@
 
   /// \brief The number of errors at the start of the given scope.
   unsigned NumErrorsAtStart;
-  
+
 public:
   Scope(Scope *Parent, unsigned ScopeFlags) {
     Init(Parent, ScopeFlags);
@@ -211,6 +216,15 @@
     return DeclsInScope.count(D) != 0;
   }
 
+  typedef PrefixListTy::const_iterator prefix_iterator;
+  prefix_iterator prefix_begin() { return PrefixesInScope.begin(); }
+  prefix_iterator prefix_end()   { return PrefixesInScope.end(); }
+  bool prefix_empty()            const { return PrefixesInScope.empty(); }
+
+  void AddPrefix(const char *P) {
+    PrefixesInScope.push_back(P);
+  }
+
   void* getEntity() const { return Entity; }
   void setEntity(void *E) { Entity = E; }
 
@@ -316,6 +330,7 @@
     if (Flags & BlockScope)         BlockParent = this;
     if (Flags & TemplateParamScope) TemplateParamParent = this;
     DeclsInScope.clear();
+    PrefixesInScope.clear();
     UsingDirectives.clear();
     Entity = 0;
     NumErrorsAtStart = 0;
Index: include/clang/Sema/Sema.h
===================================================================
--- include/clang/Sema/Sema.h	(revision 123041)
+++ include/clang/Sema/Sema.h	(working copy)
@@ -1233,7 +1233,7 @@
                               RedeclarationKind Redecl
                                 = NotForRedeclaration);
   bool LookupName(LookupResult &R, Scope *S,
-                  bool AllowBuiltinCreation = false);
+                  bool AllowBuiltinCreation = false, bool doPrefixLookup = false);
   bool LookupQualifiedName(LookupResult &R, DeclContext *LookupCtx,
                            bool InUnqualifiedLookup = false);
   bool LookupParsedName(LookupResult &R, Scope *S, CXXScopeSpec *SS,
@@ -3779,6 +3779,11 @@
                                   SourceLocation RBracLoc,
                                   MultiExprArg Args);
 
+  /// Eero support for namespace-like prefixes
+  void ActOnPrefixTypedef(Scope *CurScope,
+                          SourceLocation TypedefLoc,
+                          SourceLocation PrefixNameLoc,
+                          IdentifierInfo *PrefixName);
 
   enum PragmaOptionsAlignKind {
     POAK_Native,  // #pragma options align=native
Index: include/clang/Driver/Types.def
===================================================================
--- include/clang/Driver/Types.def	(revision 123041)
+++ include/clang/Driver/Types.def	(working copy)
@@ -44,6 +44,7 @@
 TYPE("cl",                       CL,           PP_C,            0,       "u")
 TYPE("objective-c-cpp-output",   PP_ObjC,      INVALID,         "mi",    "u")
 TYPE("objective-c",              ObjC,         PP_ObjC,         0,       "u")
+TYPE("eero",                     Eero,         PP_ObjC,         0,       "u")
 TYPE("c++-cpp-output",           PP_CXX,       INVALID,         "ii",    "u")
 TYPE("c++",                      CXX,          PP_CXX,          0,       "u")
 TYPE("objective-c++-cpp-output", PP_ObjCXX,    INVALID,         "mii",   "u")
Index: include/clang/Parse/Parser.h
===================================================================
--- include/clang/Parse/Parser.h	(revision 123041)
+++ include/clang/Parse/Parser.h	(working copy)
@@ -134,6 +134,9 @@
   /// The "depth" of the template parameters currently being parsed.
   unsigned TemplateParameterDepth;
 
+  /// Used for Eero (Python-like) indentation tracking.
+  std::deque<unsigned> indentationPositions;
+
 public:
   Parser(Preprocessor &PP, Sema &Actions);
   ~Parser();
@@ -464,6 +467,29 @@
                         const char *DiagMsg = "",
                         tok::TokenKind SkipToTok = tok::unknown);
 
+
+  /// Convenience function used with Eero
+  bool InSystemHeader(const SourceLocation& Loc) {
+    if (PP.isInPrimaryFile())
+      return false;
+    else 
+      return PP.getSourceManager().isInSystemHeader(Loc);
+  }
+
+  /// Convenience function used with Eero
+  unsigned Column(const SourceLocation& Loc) {
+    return PP.getSourceManager().getInstantiationColumnNumber(Loc);
+  }
+
+  /// Convenience function used with Eero
+  void InsertToken(const tok::TokenKind tokenKind) {
+    PP.EnterToken(Tok);
+    Tok.setKind(tokenKind);
+  }
+
+  /// Const value used with Eero
+  enum { InferredBracketOffset = 1000 };
+
   //===--------------------------------------------------------------------===//
   // Scope manipulation
 
@@ -931,10 +957,10 @@
   //===--------------------------------------------------------------------===//
   // C99 6.5: Expressions.
   
-  ExprResult ParseExpression();
+  ExprResult ParseExpression(bool isInParens = false);
   ExprResult ParseConstantExpression();
   // Expr that doesn't include commas.
-  ExprResult ParseAssignmentExpression();
+  ExprResult ParseAssignmentExpression(bool isInParens = false);
 
   ExprResult ParseExpressionWithLeadingAt(SourceLocation AtLoc);
 
@@ -1114,6 +1140,10 @@
   bool ParseObjCXXMessageReceiver(bool &IsExpr, void *&TypeOrExpr);
 
   //===--------------------------------------------------------------------===//
+  // Eero-specific Expressions
+  ExprResult ParsePrefixTypedef(SourceLocation TypedefLoc);
+
+  //===--------------------------------------------------------------------===//
   // C99 6.8: Statements and Blocks.
 
   StmtResult ParseStatement() {
Index: lib/Frontend/FrontendActions.cpp
===================================================================
--- lib/Frontend/FrontendActions.cpp	(revision 123041)
+++ lib/Frontend/FrontendActions.cpp	(working copy)
@@ -191,6 +191,7 @@
   case IK_C:
   case IK_CXX:
   case IK_ObjC:
+  case IK_Eero:
   case IK_ObjCXX:
   case IK_OpenCL:
     break;
Index: lib/Frontend/CompilerInvocation.cpp
===================================================================
--- lib/Frontend/CompilerInvocation.cpp	(revision 123041)
+++ lib/Frontend/CompilerInvocation.cpp	(working copy)
@@ -299,6 +299,7 @@
   case IK_CXX:               return "c++";
   case IK_LLVM_IR:           return "ir";
   case IK_ObjC:              return "objective-c";
+  case IK_Eero:              return "eero";
   case IK_ObjCXX:            return "objective-c++";
   case IK_OpenCL:            return "cl";
   case IK_PreprocessedC:     return "cpp-output";
@@ -1086,6 +1087,7 @@
       .Case("cl", IK_OpenCL)
       .Case("c++", IK_CXX)
       .Case("objective-c", IK_ObjC)
+      .Case("eero", IK_Eero)
       .Case("objective-c++", IK_ObjCXX)
       .Case("cpp-output", IK_PreprocessedC)
       .Case("assembler-with-cpp", IK_Asm)
@@ -1196,11 +1198,17 @@
   if (IK == IK_Asm) {
     Opts.AsmPreprocessor = 1;
   } else if (IK == IK_ObjC ||
+             IK == IK_Eero ||
              IK == IK_ObjCXX ||
              IK == IK_PreprocessedObjC ||
              IK == IK_PreprocessedObjCXX) {
     Opts.ObjC1 = Opts.ObjC2 = 1;
   }
+  
+  if (IK == IK_Eero) {
+    Opts.Eero = 1;
+    Opts.CXXOperatorNames = 1;
+  }
 
   LangStandard::Kind LangStd = LangStandard::lang_unspecified;
   if (const Arg *A = Args.getLastArg(OPT_std_EQ)) {
@@ -1228,6 +1236,7 @@
     case IK_C:
     case IK_PreprocessedC:
     case IK_ObjC:
+    case IK_Eero:
     case IK_PreprocessedObjC:
       LangStd = LangStandard::lang_gnu99;
       break;
Index: lib/Frontend/FrontendOptions.cpp
===================================================================
--- lib/Frontend/FrontendOptions.cpp	(revision 123041)
+++ lib/Frontend/FrontendOptions.cpp	(working copy)
@@ -19,6 +19,7 @@
     .Case("i", IK_PreprocessedC)
     .Case("ii", IK_PreprocessedCXX)
     .Case("m", IK_ObjC)
+    .Case("ero", IK_Eero)
     .Case("mi", IK_PreprocessedObjC)
     .Cases("mm", "M", IK_ObjCXX)
     .Case("mii", IK_PreprocessedObjCXX)
Index: lib/Sema/SemaDeclObjC.cpp
===================================================================
--- lib/Sema/SemaDeclObjC.cpp	(revision 123041)
+++ lib/Sema/SemaDeclObjC.cpp	(working copy)
@@ -1494,9 +1494,15 @@
     // Methods cannot return interface types. All ObjC objects are
     // passed by reference.
     if (resultDeclType->isObjCObjectType()) {
-      Diag(MethodLoc, diag::err_object_cannot_be_passed_returned_by_value)
-        << 0 << resultDeclType;
-      return 0;
+      if (!getLangOptions().Eero) {      
+        Diag(MethodLoc, diag::err_object_cannot_be_passed_returned_by_value)
+          << 0 << resultDeclType;
+        return 0;
+      } else { // make it a pointer instead of flagging it an error
+        QualType objectType = Context.getObjCObjectType( resultDeclType, 0, 0 );  
+        QualType pointerType = Context.getObjCObjectPointerType(objectType);
+        resultDeclType = pointerType;                    
+      }
     }
   } else // get the type for "id".
     resultDeclType = Context.getObjCIdType();
@@ -1532,10 +1538,16 @@
                             SC_None, SC_None, 0);
 
     if (ArgType->isObjCObjectType()) {
-      Diag(ArgInfo[i].NameLoc,
-           diag::err_object_cannot_be_passed_returned_by_value)
-        << 1 << ArgType;
-      Param->setInvalidDecl();
+      if (!getLangOptions().Eero) {
+        Diag(ArgInfo[i].NameLoc,
+             diag::err_object_cannot_be_passed_returned_by_value)
+          << 1 << ArgType;
+        Param->setInvalidDecl();
+      } else { // make it a pointer instead of flagging it an error
+        QualType objectType = Context.getObjCObjectType( ArgType, 0, 0 );  
+        QualType pointerType = Context.getObjCObjectPointerType(objectType);
+        Param->setType(pointerType);                    
+      }
     }
 
     Param->setObjCDeclQualifier(
@@ -1698,8 +1710,12 @@
   } else if (T->isDependentType()) {
     // Okay: we don't know what this type will instantiate to.
   } else if (!T->isObjCObjectPointerType()) {
-    Invalid = true;
-    Diag(NameLoc ,diag::err_catch_param_not_objc_type);
+    if (!getLangOptions().Eero || !T->isObjCObjectType()) {
+      Invalid = true;
+      Diag(NameLoc ,diag::err_catch_param_not_objc_type);
+    } else { // make it a pointer instead of flagging it an error
+      T = Context.getObjCObjectPointerType(T);
+    }
   } else if (T->isObjCQualifiedIdType()) {
     Invalid = true;
     Diag(NameLoc, diag::err_illegal_qualifiers_on_catch_parm);
@@ -1807,3 +1823,16 @@
   }
   return;
 }
+
+/// Eero support for namespace-like prefixes
+
+void Sema::ActOnPrefixTypedef(Scope *CurScope,
+                              SourceLocation TypedefLoc,
+                              SourceLocation PrefixNameLoc,
+                              IdentifierInfo *PrefixName) {
+
+    // TODO: add error checking for duplicate prefixes in same scope?
+    
+    CurScope->AddPrefix(PrefixName->getNameStart());
+}
+
Index: lib/Sema/SemaDecl.cpp
===================================================================
--- lib/Sema/SemaDecl.cpp	(revision 123041)
+++ lib/Sema/SemaDecl.cpp	(working copy)
@@ -123,7 +123,7 @@
     }
   } else {
     // Perform unqualified name lookup.
-    LookupName(Result, S);
+    LookupName(Result, S,false,true);
   }
   
   NamedDecl *IIDecl = 0;
@@ -2963,8 +2963,14 @@
   QualType T = NewVD->getType();
 
   if (T->isObjCObjectType()) {
-    Diag(NewVD->getLocation(), diag::err_statically_allocated_object);
-    return NewVD->setInvalidDecl();
+    if (!getLangOptions().Eero) {
+      Diag(NewVD->getLocation(), diag::err_statically_allocated_object);
+      return NewVD->setInvalidDecl();
+    } else {
+      QualType objectType = Context.getObjCObjectType( T, 0, 0 );  
+      QualType pointerType = Context.getObjCObjectPointerType(objectType);
+      NewVD->setType(pointerType);                    
+    }
   }
 
   // Emit an error if an address space was applied to decl with local storage.
@@ -6618,10 +6624,16 @@
         Record->setHasObjectMember(true);
     } else if (FDTy->isObjCObjectType()) {
       /// A field cannot be an Objective-c object
-      Diag(FD->getLocation(), diag::err_statically_allocated_object);
-      FD->setInvalidDecl();
-      EnclosingDecl->setInvalidDecl();
-      continue;
+      if (!getLangOptions().Eero) {
+        Diag(FD->getLocation(), diag::err_statically_allocated_object);
+        FD->setInvalidDecl();
+        EnclosingDecl->setInvalidDecl();
+        continue;
+      } else {
+        QualType objectType = Context.getObjCObjectType( FD->getType(), 0, 0 );  
+        QualType pointerType = Context.getObjCObjectPointerType(objectType);
+        FD->setType(pointerType);                 
+      }
     } else if (getLangOptions().ObjC1 &&
                getLangOptions().getGCMode() != LangOptions::NonGC &&
                Record &&
Index: lib/Sema/SemaLookup.cpp
===================================================================
--- lib/Sema/SemaLookup.cpp	(revision 123041)
+++ lib/Sema/SemaLookup.cpp	(working copy)
@@ -28,6 +28,7 @@
 #include "clang/AST/ExprCXX.h"
 #include "clang/Basic/Builtins.h"
 #include "clang/Basic/LangOptions.h"
+#include "clang/Lex/Preprocessor.h"
 #include "llvm/ADT/DenseSet.h"
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/SmallPtrSet.h"
@@ -1033,11 +1034,12 @@
 /// @returns The result of name lookup, which includes zero or more
 /// declarations and possibly additional information used to diagnose
 /// ambiguities.
-bool Sema::LookupName(LookupResult &R, Scope *S, bool AllowBuiltinCreation) {
+bool Sema::LookupName(LookupResult &R, Scope *S, bool AllowBuiltinCreation, bool doPrefixLookup) {
   DeclarationName Name = R.getLookupName();
   if (!Name) return false;
 
   LookupNameKind NameKind = R.getLookupKind();
+  Scope* curScope = S;
 
   if (!getLangOptions().CPlusPlus) {
     // Unqualified name lookup in C/Objective-C is purely lexical, so
@@ -1113,6 +1115,31 @@
   if (AllowBuiltinCreation)
     return LookupBuiltin(*this, R);
 
+  if (getLangOptions().Eero && doPrefixLookup) { // use Eero prefix typedefs
+
+    const std::string& name(Name.getAsString());
+    Scope* prefixScope = curScope;
+    bool found = false;
+
+    // First check for the almighty "NS" prefix
+    R.setLookupName(&(PP.getIdentifierTable().getOwn("NS" + name)));
+    found = LookupName(R, curScope);
+    
+    while (!found && prefixScope) { // now check for any explicit prefix typedefs
+      Scope::prefix_iterator it;
+      for ( Scope::prefix_iterator it = prefixScope->prefix_begin(); 
+            !found && it < prefixScope->prefix_end(); 
+            it++ ) {
+        R.setLookupName(&(PP.getIdentifierTable().getOwn(*it + name)));
+        found = LookupName(R, curScope);
+      }
+      prefixScope = prefixScope->getParent(); // keep looking in enclosing scopes
+    }
+
+    if (!found) R.setLookupName(Name); // restore orig name for diagnostics
+    return found;
+  }
+
   return false;
 }
 
@@ -2027,7 +2054,7 @@
                                   LookupNameKind NameKind,
                                   RedeclarationKind Redecl) {
   LookupResult R(*this, Name, Loc, NameKind, Redecl);
-  LookupName(R, S);
+  LookupName(R, S,false,true);
   return R.getAsSingle<NamedDecl>();
 }
 
Index: lib/Sema/SemaExprObjC.cpp
===================================================================
--- lib/Sema/SemaExprObjC.cpp	(revision 123041)
+++ lib/Sema/SemaExprObjC.cpp	(working copy)
@@ -541,7 +541,7 @@
     return ObjCSuperMessage;
   
   LookupResult Result(*this, Name, NameLoc, LookupOrdinaryName);
-  LookupName(Result, S);
+  LookupName(Result, S,false,true);
   
   switch (Result.getResultKind()) {
   case LookupResult::NotFound:
Index: lib/Sema/SemaExpr.cpp
===================================================================
--- lib/Sema/SemaExpr.cpp	(revision 123041)
+++ lib/Sema/SemaExpr.cpp	(working copy)
@@ -6457,6 +6457,27 @@
   return Opc;
 }
 
+// Eero
+static inline std::string ConvertTokenKindToBinarySelectorName(
+  tok::TokenKind Kind, bool& invert) {
+  std::string SelectorName;
+  invert = false;
+  switch (Kind) {
+    case tok::equalequal:     SelectorName = "isEqual"; break;
+    case tok::exclaimequal:   SelectorName = "isEqual"; invert = true; break;
+    case tok::plus:           SelectorName = "plus"; break;
+    case tok::minus:          SelectorName = "minus"; break;
+    case tok::star:           SelectorName = "multipliedBy"; break;
+    case tok::slash:          SelectorName = "dividedBy"; break;
+    case tok::less:           SelectorName = "isLess"; break;
+    case tok::lessequal:      SelectorName = "isGreater"; invert = true; break;      
+    case tok::greater:        SelectorName = "isGreater"; break;
+    case tok::greaterequal:   SelectorName = "isLess"; invert = true; break;
+    default:; // do nothing, leaving SelectorName empty
+  }
+  return SelectorName;
+}
+
 /// CreateBuiltinBinOp - Creates a new built-in binary operation with
 /// operator @p Opc at location @c TokLoc. This routine only supports
 /// built-in operations; ActOnBinOp handles overloaded operators.
@@ -6680,6 +6701,30 @@
   // Emit warnings for tricky precedence issues, e.g. "bitfield & 0x4 == 0"
   DiagnoseBinOpPrecedence(*this, Opc, TokLoc, lhs, rhs);
 
+  // Eero -- if both operands are object instances
+  if (getLangOptions().Eero && 
+      lhs->getType()->isObjCObjectPointerType() && 
+      rhs->getType()->isObjCObjectPointerType()) { 
+    bool invert;
+    std::string SelName = ConvertTokenKindToBinarySelectorName(Kind, invert);
+    if (!SelName.empty()) {
+      IdentifierInfo &II = PP.getIdentifierTable().getOwn(SelName);      
+      Selector Sel = PP.getSelectorTable().getUnarySelector(&II);
+      if (!Sel.isNull()) {
+        ExprResult Res = ActOnInstanceMessage(S,
+                                              lhs, 
+                                              Sel,
+                                              TokLoc,
+                                              TokLoc,
+                                              TokLoc,
+                                              MultiExprArg(*this,&rhs,1));
+        if (invert) {
+          Res = ActOnUnaryOp(S, TokLoc, tok::exclaim, Res.take());
+        }
+        return Res;
+      }
+    }
+  }
   return BuildBinOp(S, TokLoc, Opc, lhs, rhs);
 }
 
Index: lib/Lex/LiteralSupport.cpp
===================================================================
--- lib/Lex/LiteralSupport.cpp	(revision 123041)
+++ lib/Lex/LiteralSupport.cpp	(working copy)
@@ -852,7 +852,8 @@
       ++ThisTokBuf;
     }
 
-    assert(ThisTokBuf[0] == '"' && "Expected quote, lexer broken?");
+    if (!pp.getLangOptions().Eero)
+      assert(ThisTokBuf[0] == '"' && "Expected quote, lexer broken?");
     ++ThisTokBuf;
 
     // Check if this is a pascal string
Index: lib/Driver/Tools.cpp
===================================================================
--- lib/Driver/Tools.cpp	(revision 123041)
+++ lib/Driver/Tools.cpp	(working copy)
@@ -651,7 +651,7 @@
   case types::TY_PP_ObjCXX: case types::TY_PP_ObjCXXHeader:
     return true;
 
-  case types::TY_ObjC: case types::TY_ObjCHeader:
+  case types::TY_ObjC: case types::TY_Eero: case types::TY_ObjCHeader:
   case types::TY_PP_ObjC: case types::TY_PP_ObjCHeader:
     if (Args.hasArg(options::OPT_fobjc_nonfragile_abi))
       return true;
@@ -1670,7 +1670,7 @@
   case types::TY_C: case types::TY_CHeader:
   case types::TY_PP_C: case types::TY_PP_CHeader:
     return "cc1";
-  case types::TY_ObjC: case types::TY_ObjCHeader:
+  case types::TY_ObjC: case types::TY_Eero: case types::TY_ObjCHeader:
   case types::TY_PP_ObjC: case types::TY_PP_ObjCHeader:
     return "cc1obj";
   case types::TY_CXX: case types::TY_CXXHeader:
Index: lib/Driver/Types.cpp
===================================================================
--- lib/Driver/Types.cpp	(revision 123041)
+++ lib/Driver/Types.cpp	(working copy)
@@ -78,7 +78,7 @@
   case TY_Asm:
   case TY_C: case TY_PP_C:
   case TY_CL:
-  case TY_ObjC: case TY_PP_ObjC:
+  case TY_ObjC: case TY_PP_ObjC: case TY_Eero:
   case TY_CXX: case TY_PP_CXX:
   case TY_ObjCXX: case TY_PP_ObjCXX:
   case TY_CHeader: case TY_PP_CHeader:
@@ -109,7 +109,7 @@
   default:
     return false;
 
-  case TY_ObjC: case TY_PP_ObjC:
+  case TY_ObjC: case TY_PP_ObjC: case TY_Eero:
   case TY_ObjCXX: case TY_PP_ObjCXX:
   case TY_ObjCHeader: case TY_PP_ObjCHeader:
   case TY_ObjCXXHeader: case TY_PP_ObjCXXHeader:
@@ -135,6 +135,7 @@
            .Case("c", TY_C)
            .Case("i", TY_PP_C)
            .Case("m", TY_ObjC)
+           .Case("ero", TY_Eero)
            .Case("M", TY_ObjCXX)
            .Case("h", TY_CHeader)
            .Case("C", TY_CXX)
Index: lib/Parse/ParseDecl.cpp
===================================================================
--- lib/Parse/ParseDecl.cpp	(revision 123041)
+++ lib/Parse/ParseDecl.cpp	(working copy)
@@ -389,8 +389,9 @@
 
   // C99 6.7.2.3p6: Handle "struct-or-union identifier;", "enum { X };"
   // declaration-specifiers init-declarator-list[opt] ';'
-  if (Tok.is(tok::semi)) {
-    if (RequireSemi) ConsumeToken();
+  if (Tok.is(tok::semi) || 
+      (getLang().Eero && Tok.isAtStartOfLine() && !InSystemHeader(Tok.getLocation()))) {
+    if (Tok.is(tok::semi) && RequireSemi) ConsumeToken();
     Decl *TheDecl = Actions.ParsedFreeStandingDeclSpec(getCurScope(), AS_none,
                                                            DS);
     DS.complete(TheDecl);
@@ -491,18 +492,22 @@
   if (DeclEnd)
     *DeclEnd = Tok.getLocation();
 
-  if (Context != Declarator::ForContext &&
-      ExpectAndConsume(tok::semi,
-                       Context == Declarator::FileContext
-                         ? diag::err_invalid_token_after_toplevel_declarator
-                         : diag::err_expected_semi_declaration)) {
-    // Okay, there was no semicolon and one was expected.  If we see a
-    // declaration specifier, just assume it was missing and continue parsing.
-    // Otherwise things are very confused and we skip to recover.
-    if (!isDeclarationSpecifier()) {
-      SkipUntil(tok::r_brace, true, true);
-      if (Tok.is(tok::semi))
+  if (Context != Declarator::ForContext) {
+    if (getLang().Eero) {
+      if (Tok.is(tok::semi)) 
         ConsumeToken();
+    } else if (ExpectAndConsume(tok::semi,
+                                Context == Declarator::FileContext
+                                  ? diag::err_invalid_token_after_toplevel_declarator
+                                  : diag::err_expected_semi_declaration)) {
+      // Okay, there was no semicolon and one was expected.  If we see a
+      // declaration specifier, just assume it was missing and continue parsing.
+      // Otherwise things are very confused and we skip to recover.
+      if (!isDeclarationSpecifier()) {
+        SkipUntil(tok::r_brace, true, true);
+        if (Tok.is(tok::semi))
+          ConsumeToken();
+      }
     }
   }
 
@@ -877,13 +882,24 @@
                                         AccessSpecifier AS,
                                         DeclSpecContext DSContext) {  
   DS.SetRangeStart(Tok.getLocation());
+  bool firstPass = true;
   while (1) {
     bool isInvalid = false;
     const char *PrevSpec = 0;
     unsigned DiagID = 0;
 
     SourceLocation Loc = Tok.getLocation();
+      
+    if (getLang().Eero && 
+        !firstPass && 
+        Tok.isAtStartOfLine() && 
+        !InSystemHeader(Loc)) {
+      goto DoneWithDeclSpec; // !!! a goto? !!!
+    }
 
+    if (firstPass)
+      firstPass = false;
+    
     switch (Tok.getKind()) {
     default:
     DoneWithDeclSpec:
@@ -1908,15 +1924,17 @@
 
     if (Tok.is(tok::semi)) {
       ConsumeToken();
-    } else if (Tok.is(tok::r_brace)) {
-      ExpectAndConsume(tok::semi, diag::ext_expected_semi_decl_list);
-      break;
-    } else {
-      ExpectAndConsume(tok::semi, diag::err_expected_semi_decl_list);
-      // Skip to end of block or statement to avoid ext-warning on extra ';'.
-      SkipUntil(tok::r_brace, true, true);
-      // If we stopped at a ';', eat it.
-      if (Tok.is(tok::semi)) ConsumeToken();
+    } else if (!getLang().Eero) {
+      if (Tok.is(tok::r_brace)) {
+        ExpectAndConsume(tok::semi, diag::ext_expected_semi_decl_list);
+        break;
+      } else {
+        ExpectAndConsume(tok::semi, diag::err_expected_semi_decl_list);
+        // Skip to end of block or statement to avoid ext-warning on extra ';'.
+        SkipUntil(tok::r_brace, true, true);
+        // If we stopped at a ';', eat it.
+        if (Tok.is(tok::semi)) ConsumeToken();
+      }
     }
   }
 
@@ -1933,6 +1951,10 @@
                       AttrList.get());
   StructScope.Exit();
   Actions.ActOnTagFinishDefinition(getCurScope(), TagDecl, RBraceLoc);
+
+  if (getLang().Eero && Tok.isAtStartOfLine() && !InSystemHeader(RBraceLoc)) {
+    InsertToken(tok::semi);
+  }
 }
 
 
@@ -2306,6 +2328,11 @@
       return false;
     if (TryAltiVecVectorToken())
       return true;
+    if (getLang().Eero && 
+        (NextToken().is(tok::identifier) &&     // variadic class method call
+         GetLookAheadToken(2).is(tok::colon) || 
+         NextToken().is(tok::colon)))           // empty-selector-name-method call
+      return false; 
     // Fall through.
   case tok::kw_typename: // typename T::type
     // Annotate typenames and C++ scope specifiers.  If we get one, just
@@ -2329,6 +2356,10 @@
 
     // storage-class-specifier
   case tok::kw_typedef:
+    if (getLang().Eero && 
+        GetLookAheadToken(1).is(tok::identifier) && 
+        GetLookAheadToken(2).is(tok::ellipsis) && 
+        GetLookAheadToken(3).is(tok::ellipsis) ) {  return false; }
   case tok::kw_extern:
   case tok::kw___private_extern__:
   case tok::kw_static:
@@ -2791,6 +2822,12 @@
     goto PastIdentifier;
   }
     
+  if (getLang().Eero && 
+      Tok.isAtStartOfLine() && 
+      !InSystemHeader(Tok.getLocation())) {
+    return;
+  }
+
   if (Tok.is(tok::l_paren)) {
     // direct-declarator: '(' declarator ')'
     // direct-declarator: '(' attributes declarator ')'
@@ -2837,7 +2874,7 @@
     D.AddAttributes(Attr.AttrList, AttrEndLoc);
   }
 
-  while (1) {
+  while (!getLang().Eero || !Tok.isAtStartOfLine() || InSystemHeader(Tok.getLocation())) {
     if (Tok.is(tok::l_paren)) {
       // The paren may be part of a C++ direct initializer, eg. "int x(1);".
       // In such a case, check if we actually have a function declarator; if it
Index: lib/Parse/ParseObjc.cpp
===================================================================
--- lib/Parse/ParseObjc.cpp	(revision 123041)
+++ lib/Parse/ParseObjc.cpp	(working copy)
@@ -318,14 +318,19 @@
 
   while (1) {
     // If this is a method prototype, parse it.
-    if (Tok.is(tok::minus) || Tok.is(tok::plus)) {
+    if ((Tok.is(tok::minus) || Tok.is(tok::plus)) ||
+        (getLang().Eero && (Tok.is(tok::identifier) || Tok.is(tok::colon)))) {
       Decl *methodPrototype =
         ParseObjCMethodPrototype(interfaceDecl, MethodImplKind);
       allMethods.push_back(methodPrototype);
       // Consume the ';' here, since ParseObjCMethodPrototype() is re-used for
       // method definitions.
-      ExpectAndConsume(tok::semi, diag::err_expected_semi_after_method_proto,
-                       "", tok::semi);
+      if (!getLang().Eero) {
+        ExpectAndConsume(tok::semi, diag::err_expected_semi_after_method_proto,
+                         "", tok::semi);
+      } else if (Tok.is(tok::semi)) {
+        ConsumeToken();
+      }
       continue;
     }
     if (Tok.is(tok::l_paren)) {
@@ -429,8 +434,12 @@
       DeclSpec DS;
       ParseStructDeclaration(DS, Callback);
 
-      ExpectAndConsume(tok::semi, diag::err_expected_semi_decl_list, "",
-                       tok::at);
+      if (!getLang().Eero) {
+        ExpectAndConsume(tok::semi, diag::err_expected_semi_decl_list, "",
+                         tok::at);
+      } else if (Tok.is(tok::semi)) {
+        ConsumeToken();
+      }  
       break;
     }
   }
@@ -565,10 +574,18 @@
 ///
 Decl *Parser::ParseObjCMethodPrototype(Decl *IDecl,
                                        tok::ObjCKeywordKind MethodImplKind) {
-  assert((Tok.is(tok::minus) || Tok.is(tok::plus)) && "expected +/-");
+  if (!getLang().Eero)
+    assert((Tok.is(tok::minus) || Tok.is(tok::plus)) && "expected +/-");
 
-  tok::TokenKind methodType = Tok.getKind();
-  SourceLocation mLoc = ConsumeToken();
+  tok::TokenKind methodType;
+  SourceLocation mLoc;  
+  if (!getLang().Eero || Tok.is(tok::minus) || Tok.is(tok::plus)) {
+    methodType = Tok.getKind();
+    mLoc = ConsumeToken();
+  } else {
+    methodType = tok::unknown;
+    mLoc = Tok.getLocation();
+  }
   Decl *MDecl = ParseObjCMethodDecl(mLoc, methodType, IDecl,MethodImplKind);
   // Since this rule is used for both method declarations and definitions,
   // the caller is (optionally) responsible for consuming the ';'.
@@ -743,11 +760,17 @@
 ///     '(' objc-type-qualifiers[opt] ')'
 ///
 ParsedType Parser::ParseObjCTypeName(ObjCDeclSpec &DS, bool IsParameter) {
-  assert(Tok.is(tok::l_paren) && "expected (");
+  if (!getLang().Eero)
+    assert(Tok.is(tok::l_paren) && "expected (");
 
-  SourceLocation LParenLoc = ConsumeParen();
+  SourceLocation LParenLoc;
   SourceLocation TypeStartLoc = Tok.getLocation();
 
+  // Eero support for ObjC prototypes (for header compatibility)
+  if (Tok.is(tok::l_paren)) { 
+    LParenLoc = ConsumeParen();
+  }
+
   // Parse type qualifiers, in, inout, etc.
   ParseObjCTypeQualifierList(DS, IsParameter);
 
@@ -758,20 +781,67 @@
       Ty = TypeSpec.get();
   }
 
-  if (Tok.is(tok::r_paren))
-    ConsumeParen();
-  else if (Tok.getLocation() == TypeStartLoc) {
-    // If we didn't eat any tokens, then this isn't a type.
-    Diag(Tok, diag::err_expected_type);
-    SkipUntil(tok::r_paren);
-  } else {
-    // Otherwise, we found *something*, but didn't get a ')' in the right
-    // place.  Emit an error then return what we have as the type.
-    MatchRHSPunctuation(tok::r_paren, LParenLoc);
+  if ( LParenLoc.isValid() ) {
+    if (Tok.is(tok::r_paren))
+      ConsumeParen();
+    else if (Tok.getLocation() == TypeStartLoc) {
+      // If we didn't eat any tokens, then this isn't a type.
+      Diag(Tok, diag::err_expected_type);
+      SkipUntil(tok::r_paren);
+    } else {
+      // Otherwise, we found *something*, but didn't get a ')' in the right
+      // place.  Emit an error then return what we have as the type.
+      MatchRHSPunctuation(tok::r_paren, LParenLoc);
+    }
+  } else if (Ty == 0) {
+    Diag(TypeStartLoc, diag::err_expected_type);
   }
   return Ty;
 }
 
+/// Eero helper function which derives a variable name from a camel case 
+/// selector name (full name begins with lowercase characters, new 
+/// words start with uppercase characters).
+/// The variable name construction rules are: 
+///   1) If the selector name contains words separated by camel case, then the
+///      last word (scanning left to right), converted entirely to lowercase, is used.
+///   2) The first camel case word containing two consecutive uppercase characters
+///      encountered (scanning left to right) is used, along with all subsequent 
+///      words; no character cases are modified.
+///   3) If no uppercase characters are encountered, the entire selector name is used.
+///   4) If the first character in the selector name is uppercase, the entire selector 
+///      name is used.
+///
+/// Examples:
+///   1) Selector name "initWithString" results in variable name "string"
+///   2) Selector name "initWithUTF8String" results in variable name "UTF8String"
+///   3) Selector name "compare" results in variable name "compare"
+///   4) Selector name "CreateNewString" results in variable name "CreateNewString"
+///
+static std::string NameFromCamelCase(const std::string& aName)
+{
+  std::string name(aName);
+  size_t pos(std::string::npos);
+  bool changeCase(true);
+  
+  for (size_t i=0; i < name.length(); i++) {          
+    if (isupper(name[i])) {
+      if (i == pos + 1) {  // two consecutive uppercase chars (or if name begins with uppercase)
+        changeCase = false;
+        break;
+      } else {
+        pos = i;
+      }
+    }
+  }
+  if (pos != std::string::npos) {
+    if (changeCase)
+      name[pos] = tolower(name[pos]);
+    name = name.substr(pos);
+  }
+  return name;
+}
+
 ///   objc-method-decl:
 ///     objc-selector
 ///     objc-keyword-selector objc-parmlist[opt]
@@ -806,17 +876,32 @@
                                   tok::ObjCKeywordKind MethodImplKind) {
   ParsingDeclRAIIObject PD(*this);
 
+  bool objcSyntax(true);
+  if (getLang().Eero && mType == tok::unknown) {    
+    objcSyntax = false;
+    if (Tok.isObjCAtKeyword(tok::objc_class)) {
+      ConsumeToken();
+      mType = tok::plus;
+    } else {
+      mType = tok::minus;
+    }
+  }
+
   if (Tok.is(tok::code_completion)) {
     Actions.CodeCompleteObjCMethodDecl(getCurScope(), mType == tok::minus, 
                                        /*ReturnType=*/ ParsedType(), IDecl);
     ConsumeCodeCompletionToken();
   }
 
-  // Parse the return type if present.
   ParsedType ReturnType;
   ObjCDeclSpec DSRet;
-  if (Tok.is(tok::l_paren))
+  if (objcSyntax) { // Parse the return type if present.
+    if (Tok.is(tok::l_paren))
+      ReturnType = ParseObjCTypeName(DSRet, false);
+  } else { // Eero return type defaults to void    
+    InsertToken(tok::kw_void); // look into a cleaner way to do this
     ReturnType = ParseObjCTypeName(DSRet, false);
+  }
 
   // If attributes exist before the method, parse them.
   llvm::OwningPtr<AttributeList> MethodAttrs;
@@ -834,16 +919,41 @@
   IdentifierInfo *SelIdent = ParseObjCSelectorPiece(selLoc);
 
   // An unnamed colon is valid.
-  if (!SelIdent && Tok.isNot(tok::colon)) { // missing selector name.
-    Diag(Tok, diag::err_expected_selector_for_method)
+  if (!SelIdent) { // missing selector name.
+    if (Tok.isNot(tok::colon)) {
+      Diag(Tok, diag::err_expected_selector_for_method)
       << SourceRange(mLoc, Tok.getLocation());
-    // Skip until we get a ; or {}.
-    SkipUntil(tok::r_brace);
-    return 0;
+      // Skip until we get a ; or {}.
+      SkipUntil(tok::r_brace);
+      return 0;
+    } else if (!objcSyntax) {
+      ConsumeToken();
+    }
   }
 
+  bool doneParsing = false;  
+  if (objcSyntax) {
+    if (Tok.isNot(tok::colon)) {
+      doneParsing = true;
+    }
+  } else { // Eero syntax
+    if (Tok.isAtStartOfLine() || Tok.is(tok::kw___attribute)) {
+      doneParsing = true;
+    } else if (Tok.is(tok::comma) && NextToken().is(tok::kw_return)) {
+      doneParsing = true;
+      ConsumeToken(); // comma
+      SourceLocation retLoc = ConsumeToken(); // return
+      if (Tok.isAtStartOfLine()) {
+        Diag(PP.getLocForEndOfToken(retLoc), diag::err_expected_type);
+        SkipUntil(tok::semi);
+      } else {
+        ReturnType = ParseObjCTypeName(DSRet, false);
+      }
+    }
+  }
+
   llvm::SmallVector<DeclaratorChunk::ParamInfo, 8> CParamInfo;
-  if (Tok.isNot(tok::colon)) {
+  if (doneParsing) {
     // If attributes exist after the method, parse them.
     if (getLang().ObjC2 && Tok.is(tok::kw___attribute))
       MethodAttrs.reset(addAttributeLists(MethodAttrs.take(),
@@ -863,21 +973,53 @@
 
   llvm::SmallVector<IdentifierInfo *, 12> KeyIdents;
   llvm::SmallVector<Sema::ObjCArgInfo, 12> ArgInfos;
+  bool isVariadic = false;
 
   while (1) {
     Sema::ObjCArgInfo ArgInfo;
+    ArgInfo.Type = ParsedType();
+    ArgInfo.Name = 0;
+    SourceLocation argTypeLoc;
 
     // Each iteration parses a single keyword argument.
-    if (Tok.isNot(tok::colon)) {
-      Diag(Tok, diag::err_expected_colon);
-      break;
+    if (objcSyntax) {
+      if (Tok.isNot(tok::colon)) {
+        Diag(Tok, diag::err_expected_colon);
+        break;
+      }
+      ConsumeToken(); // Eat the ':'.
+
+      if (Tok.is(tok::l_paren)) // Parse the argument type if present.
+        ArgInfo.Type = ParseObjCTypeName(ArgInfo.DeclSpec, true);
+
+    } else { // Eero syntax
+      if (Tok.is(tok::pipe)) { // a variable name has been specified
+        ConsumeToken(); // "|"
+        ArgInfo.Name = Tok.getIdentifierInfo();
+        ArgInfo.NameLoc = ConsumeToken(); // Eat the arg name identifier
+      }      
+      // Parse the argument type
+      if (Tok.is(tok::identifier) || isTypeSpecifierQualifier()) {
+        if (!SelIdent || !Tok.isAtStartOfLine()) {
+          argTypeLoc = Tok.getLocation();
+          ArgInfo.Type = ParseObjCTypeName(ArgInfo.DeclSpec, true);
+        }
+      } else if (Tok.is(tok::comma) || Tok.is(tok::pipe) || Tok.isAtStartOfLine()) {
+        // If there is no type present to parse, which actually means
+        // no selector, make the selector empty and use the parsed 
+        // selector's identifier for the type.
+        if (SelIdent) { 
+          ArgInfo.Type = Actions.getTypeName(*SelIdent, selLoc, getCurScope());
+          SelIdent = 0;
+        }
+      }
+      if (ArgInfo.Type == 0) {
+        Diag(PP.getLocForEndOfToken(selLoc), diag::err_expected_type);
+        SkipUntil(tok::semi);
+        break;
+      }
     }
-    ConsumeToken(); // Eat the ':'.
 
-    ArgInfo.Type = ParsedType();
-    if (Tok.is(tok::l_paren)) // Parse the argument type if present.
-      ArgInfo.Type = ParseObjCTypeName(ArgInfo.DeclSpec, true);
-
     // If attributes exist before the argument name, parse them.
     ArgInfo.ArgAttrs = 0;
     if (getLang().ObjC2 && Tok.is(tok::kw___attribute))
@@ -896,19 +1038,72 @@
       KeyIdents.pop_back();
       break;
     }
-    
-    if (Tok.isNot(tok::identifier)) {
-      Diag(Tok, diag::err_expected_ident); // missing argument name.
-      break;
+
+    if (objcSyntax) {
+      if (Tok.isNot(tok::identifier)) {
+        Diag(Tok, diag::err_expected_ident); // missing argument name.
+        break;
+      }
+      ArgInfo.Name = Tok.getIdentifierInfo();
+      ArgInfo.NameLoc = Tok.getLocation();
+      ConsumeToken(); // Eat the identifier.
+      
+    } else { // Eero syntax
+      doneParsing = true;
+      if (ArgInfo.Name == 0) { // variable name not already defined
+        if (Tok.is(tok::pipe)) { // a variable name has been specified
+          ConsumeToken(); // "|"
+          ArgInfo.Name = Tok.getIdentifierInfo();
+          ArgInfo.NameLoc = ConsumeToken(); // Eat the arg name identifier
+        } else {
+          if (!SelIdent) { // if empty selector
+            ArgInfo.Name = &PP.getIdentifierTable().get("unnamed");
+          } else if (KeyIdents.empty()) { // if first selector (method name),
+            ArgInfo.Name =                // derive arg name from it
+              &PP.getIdentifierTable().get(NameFromCamelCase(SelIdent->getName()));
+          } else { // use entire selector name
+            ArgInfo.Name = SelIdent;
+          }
+          ArgInfo.NameLoc = argTypeLoc;
+        }
+      }
+      
+      if (Tok.is(tok::comma)) {
+        ConsumeToken(); // Eat the ','.
+        doneParsing = false;
+      }
+      if (Tok.is(tok::ellipsis)) {
+        if (doneParsing)
+          Diag(Tok, diag::err_expected_comma);
+        else {      
+          isVariadic = true;
+          ConsumeToken();
+          if (Tok.is(tok::comma)) {
+            ConsumeToken(); // Eat the ','.
+            doneParsing = false;
+          } else {
+            doneParsing = true;
+          }
+        }
+      }
+      if (!doneParsing && Tok.is(tok::kw_return)) {
+        doneParsing = true;
+        SourceLocation retLoc = ConsumeToken(); // Eat the 'return'
+        if (Tok.isAtStartOfLine()) {
+          Diag(PP.getLocForEndOfToken(retLoc), diag::err_expected_type);
+          SkipUntil(tok::semi);
+        } else {
+          ReturnType = ParseObjCTypeName(DSRet, false);
+        }
+      }
     }
 
-    ArgInfo.Name = Tok.getIdentifierInfo();
-    ArgInfo.NameLoc = Tok.getLocation();
-    ConsumeToken(); // Eat the identifier.
-
     ArgInfos.push_back(ArgInfo);
     KeyIdents.push_back(SelIdent);
 
+    if (doneParsing)
+      break;
+    
     // Code completion for the next piece of the selector.
     if (Tok.is(tok::code_completion)) {
       ConsumeCodeCompletionToken();
@@ -922,15 +1117,28 @@
     }
     
     // Check for another keyword selector.
-    SourceLocation Loc;
-    SelIdent = ParseObjCSelectorPiece(Loc);
-    if (!SelIdent && Tok.isNot(tok::colon))
-      break;
+    if (objcSyntax) {
+      SourceLocation Loc;
+      SelIdent = ParseObjCSelectorPiece(Loc);
+      if (!SelIdent && Tok.isNot(tok::colon))
+        break;
+    } else { // Eero syntax      
+      if (Tok.is(tok::identifier)) {
+        SelIdent = ParseObjCSelectorPiece(selLoc);
+        if (!SelIdent) { // it was an empty colon or a bad selector
+          Diag(Tok, diag::err_expected_ident); // missing selector name.
+          break;
+        }
+      } else { // probably an unnamed selector       
+        if (Tok.is(tok::colon)) { // colon optional in Eero, but consume if present
+          ConsumeToken(); // ":"
+        }
+        SelIdent = 0;
+      }
+    }
     // We have a selector or a colon, continue parsing.
   }
 
-  bool isVariadic = false;
-
   // Parse the (optional) parameter list.
   while (Tok.is(tok::comma)) {
     ConsumeToken();
@@ -1074,14 +1282,20 @@
     }
 
     // Set the default visibility to private.
+    bool foundAtKeyword(false);
     if (Tok.is(tok::at)) { // parse objc-visibility-spec
       ConsumeToken(); // eat the @ sign
-      
+      foundAtKeyword = true;
       if (Tok.is(tok::code_completion)) {
         Actions.CodeCompleteObjCAtVisibility(getCurScope());
         ConsumeCodeCompletionToken();
       }
+    }
       
+    if (foundAtKeyword || 
+        (getLang().Eero && 
+         Tok.getObjCKeywordID() != tok::objc_not_keyword)) { // it is an objc keyword
+
       switch (Tok.getObjCKeywordID()) {
       case tok::objc_private:
       case tok::objc_public:
@@ -1092,6 +1306,7 @@
         continue;
       default:
         Diag(Tok, diag::err_objc_illegal_visibility_spec);
+        SkipUntil(tok::r_brace);
         continue;
       }
     }
@@ -1131,7 +1346,7 @@
 
     if (Tok.is(tok::semi)) {
       ConsumeToken();
-    } else {
+    } else if (!getLang().Eero) {
       Diag(Tok, diag::err_expected_semi_decl_list);
       // Skip to end of block or statement
       SkipUntil(tok::r_brace, true, true);
@@ -1506,24 +1721,35 @@
 StmtResult
 Parser::ParseObjCSynchronizedStmt(SourceLocation atLoc) {
   ConsumeToken(); // consume synchronized
-  if (Tok.isNot(tok::l_paren)) {
+  if (!getLang().Eero && Tok.isNot(tok::l_paren)) {
     Diag(Tok, diag::err_expected_lparen_after) << "@synchronized";
     return StmtError();
   }
-  ConsumeParen();  // '('
+  SourceLocation LParenLoc;
+  if (Tok.is(tok::l_paren))
+    LParenLoc = ConsumeParen();  // '('
   ExprResult Res(ParseExpression());
   if (Res.isInvalid()) {
     SkipUntil(tok::semi);
     return StmtError();
   }
-  if (Tok.isNot(tok::r_paren)) {
-    Diag(Tok, diag::err_expected_lbrace);
-    return StmtError();
+
+  if (LParenLoc.isValid()) {
+    if (Tok.is(tok::r_paren)) {
+      ConsumeParen();  // ')'
+    } else {
+      Diag(Tok, diag::err_expected_lbrace);
+      return StmtError();
+    }
   }
-  ConsumeParen();  // ')'
+
   if (Tok.isNot(tok::l_brace)) {
-    Diag(Tok, diag::err_expected_lbrace);
-    return StmtError();
+    if (!getLang().Eero) {
+      Diag(Tok, diag::err_expected_lbrace);
+      return StmtError();
+    } else { // it's easiest if we just inject an opening brace
+      InsertToken(tok::l_brace);
+    }
   }
   // Enter a scope to hold everything within the compound stmt.  Compound
   // statements can always hold declarations.
@@ -1553,8 +1779,12 @@
 
   ConsumeToken(); // consume try
   if (Tok.isNot(tok::l_brace)) {
-    Diag(Tok, diag::err_expected_lbrace);
-    return StmtError();
+    if (!getLang().Eero) {
+      Diag(Tok, diag::err_expected_lbrace);
+      return StmtError();
+    } else { // it's easiest if we just inject an opening brace      
+      InsertToken(tok::l_brace);
+    }
   }
   StmtVector CatchStmts(Actions);
   StmtResult FinallyStmt;
@@ -1577,8 +1807,10 @@
     if (Tok.isObjCAtKeyword(tok::objc_catch)) {
       Decl *FirstPart = 0;
       ConsumeToken(); // consume catch
-      if (Tok.is(tok::l_paren)) {
-        ConsumeParen();
+      if (Tok.is(tok::l_paren) || getLang().Eero) {
+        SourceLocation LParenLoc;
+        if (Tok.is(tok::l_paren))
+          LParenLoc = ConsumeParen();
         ParseScope CatchScope(this, Scope::DeclScope|Scope::AtCatchScope);
         if (Tok.isNot(tok::ellipsis)) {
           DeclSpec DS;
@@ -1599,10 +1831,12 @@
 
         if (Tok.is(tok::r_paren))
           RParenLoc = ConsumeParen();
-        else // Skip over garbage, until we get to ')'.  Eat the ')'.
+        else if (LParenLoc.isValid()) // Skip over garbage, until we get to ')'.  Eat the ')'.
           SkipUntil(tok::r_paren, true, false);
 
         StmtResult CatchBody(true);
+        if (getLang().Eero)
+          InsertToken(tok::l_brace);
         if (Tok.is(tok::l_brace))
           CatchBody = ParseCompoundStatementBody();
         else
@@ -1629,6 +1863,8 @@
       ParseScope FinallyScope(this, Scope::DeclScope);
 
       StmtResult FinallyBody(true);
+      if (getLang().Eero)
+        InsertToken(tok::l_brace);
       if (Tok.is(tok::l_brace))
         FinallyBody = ParseCompoundStatementBody();
       else
@@ -1668,6 +1904,10 @@
     ConsumeToken();
   }
 
+  if (getLang().Eero) { // it's easiest if we just inject an opening brace
+    InsertToken(tok::l_brace);
+  }
+
   // We should have an opening brace now.
   if (Tok.isNot(tok::l_brace)) {
     Diag(Tok, diag::err_expected_method_body);
@@ -1869,16 +2109,22 @@
 ///     type-name
 ///
 ExprResult Parser::ParseObjCMessageExpression() {
-  assert(Tok.is(tok::l_square) && "'[' expected");
-  SourceLocation LBracLoc = ConsumeBracket(); // consume '['
+  if (!getLang().Eero)
+    assert(Tok.is(tok::l_square) && "'[' expected");
 
+  SourceLocation LBracLoc;
+  if (Tok.is(tok::l_square)) // first level brackets are optional for Eero
+    LBracLoc = ConsumeBracket(); // consume '['
+  else 
+    LBracLoc = Tok.getLocation();
+
   if (Tok.is(tok::code_completion)) {
     Actions.CodeCompleteObjCMessageReceiver(getCurScope());
     ConsumeCodeCompletionToken();
     SkipUntil(tok::r_square);
     return ExprError();
   }
-  
+
   if (getLang().CPlusPlus) {
     // We completely separate the C and C++ cases because C++ requires
     // more complicated (read: slower) parsing. 
@@ -2012,21 +2258,47 @@
   llvm::SmallVector<IdentifierInfo *, 12> KeyIdents;
   ExprVector KeyExprs(Actions);
 
+  bool parseArguments = false;
+
   if (Tok.is(tok::colon)) {
+    parseArguments = true;
+    if (getLang().Eero && !selIdent) {
+      ConsumeToken(); // ":"
+    }
+  } else if (getLang().Eero &&
+             selIdent && 
+             !Tok.isAtStartOfLine() &&
+             (Tok.is(tok::identifier) || 
+              Tok.is(tok::numeric_constant) || 
+              Tok.is(tok::char_constant) || 
+              Tok.is(tok::string_literal) || 
+              Tok.is(tok::wide_string_literal) || 
+              Tok.is(tok::l_square)|| 
+              Tok.is(tok::l_paren))) {
+    parseArguments = true;
+  }   
+
+  bool variadicArguments = false;
+  if (parseArguments) {
     while (1) {
       // Each iteration parses a single keyword argument.
       KeyIdents.push_back(selIdent);
 
-      if (Tok.isNot(tok::colon)) {
-        Diag(Tok, diag::err_expected_colon);
-        // We must manually skip to a ']', otherwise the expression skipper will
-        // stop at the ']' when it skips to the ';'.  We want it to skip beyond
-        // the enclosing expression.
-        SkipUntil(tok::r_square);
-        return ExprError();
+      if (!getLang().Eero) { 
+        if (Tok.isNot(tok::colon)) {
+          Diag(Tok, diag::err_expected_colon);
+          // We must manually skip to a ']', otherwise the expression skipper will
+          // stop at the ']' when it skips to the ';'.  We want it to skip beyond
+          // the enclosing expression.
+          SkipUntil(tok::r_square);
+          return ExprError();
+        }
+        ConsumeToken(); // Eat the ':'.
+      } else if (Tok.is(tok::colon)) { // for Eero, colon indicates variadic args
+        ConsumeToken(); // Eat the ':'.
+        variadicArguments = true;
       }
 
-      ConsumeToken(); // Eat the ':'.
       ///  Parse the expression after ':'
       ExprResult Res(ParseAssignmentExpression());
       if (Res.isInvalid()) {
@@ -2056,12 +2328,27 @@
                                                   KeyIdents.size());
         ConsumeCodeCompletionToken();
       }
-            
-      // Check for another keyword selector.
-      selIdent = ParseObjCSelectorPiece(Loc);
-      if (!selIdent && Tok.isNot(tok::colon))
-        break;
-      // We have a selector or a colon, continue parsing.
+      
+      if (!getLang().Eero) {      
+        // Check for another keyword selector.
+        selIdent = ParseObjCSelectorPiece(Loc);
+        if (!selIdent && Tok.isNot(tok::colon))
+          break;
+        // We have a selector or a colon, continue parsing.
+      } else { // Eero
+        if (!variadicArguments && Tok.is(tok::comma)) { // eat the comma and keep going
+          ConsumeToken(); 
+        } else {
+          break;
+        }
+        if (Tok.is(tok::identifier) && 
+            (NextToken().isNot(tok::comma) && !NextToken().isAtStartOfLine())) {
+          selIdent = ParseObjCSelectorPiece(Loc);
+        } else { // unnamed selector (parameter), loop to parse argument
+          selIdent = 0;
+          Loc = Tok.getLocation();
+        } 
+      }
     }
     // Parse the, optional, argument list, comma separated.
     while (Tok.is(tok::comma)) {
@@ -2088,21 +2375,34 @@
     SkipUntil(tok::r_square);
     return ExprError();
   }
-    
-  if (Tok.isNot(tok::r_square)) {
-    if (Tok.is(tok::identifier))
-      Diag(Tok, diag::err_expected_colon);
-    else
-      Diag(Tok, diag::err_expected_rsquare);
-    // We must manually skip to a ']', otherwise the expression skipper will
-    // stop at the ']' when it skips to the ';'.  We want it to skip beyond
-    // the enclosing expression.
-    SkipUntil(tok::r_square);
-    return ExprError();
+
+  SourceLocation RBracLoc;
+
+  if (!getLang().Eero) {
+    if (Tok.isNot(tok::r_square)) {
+      if (Tok.is(tok::identifier))
+        Diag(Tok, diag::err_expected_colon);
+      else
+        Diag(Tok, diag::err_expected_rsquare);
+      // We must manually skip to a ']', otherwise the expression skipper will
+      // stop at the ']' when it skips to the ';'.  We want it to skip beyond
+      // the enclosing expression.
+      SkipUntil(tok::r_square);
+      return ExprError();
+    }
+    RBracLoc = ConsumeBracket(); // consume ']'
+  } else {  
+    if (BracketCount == InferredBracketOffset) { // close inferred bracket
+      BracketCount = 0;
+    } else if (BracketCount != 0) {
+      RBracLoc = MatchRHSPunctuation(tok::r_square, LBracLoc);
+    }    
+    if (variadicArguments) { // Eero automatically adds a nil/NULL to the end      
+      ExprResult nilArg = Actions.ActOnGNUNullExpr(SourceLocation());
+      KeyExprs.push_back(nilArg.release());
+    }
   }
 
-  SourceLocation RBracLoc = ConsumeBracket(); // consume ']'
-
   unsigned nKeys = KeyIdents.size();
   if (nKeys == 0)
     KeyIdents.push_back(selIdent);
@@ -2265,3 +2565,20 @@
   return Owned(Actions.ParseObjCSelectorExpression(Sel, AtLoc, SelectorLoc,
                                                    LParenLoc, RParenLoc));
  }
+
+/// \brief Parse Eero "typedef XX... ..." namespace-like prefixes.
+///
+ExprResult
+Parser::ParsePrefixTypedef(SourceLocation TypedefLoc) {
+  IdentifierInfo* prefixIdentInfo = Tok.getIdentifierInfo();
+  SourceLocation prefixLoc = ConsumeToken();
+  ConsumeToken(); // ellipsis
+  ConsumeToken(); // ellipsis
+
+  Actions.ActOnPrefixTypedef(getCurScope(),
+                             TypedefLoc,
+                             prefixLoc,
+                             prefixIdentInfo);
+  return ExprEmpty();
+}
+
Index: lib/Parse/ParseExpr.cpp
===================================================================
--- lib/Parse/ParseExpr.cpp	(revision 123041)
+++ lib/Parse/ParseExpr.cpp	(working copy)
@@ -175,8 +175,8 @@
 ///         assignment-expression
 ///         expression ',' assignment-expression
 ///
-ExprResult Parser::ParseExpression() {
-  ExprResult LHS(ParseAssignmentExpression());
+ExprResult Parser::ParseExpression(bool isInParens) {
+  ExprResult LHS(ParseAssignmentExpression(isInParens));
   if (LHS.isInvalid()) return move(LHS);
 
   return ParseRHSOfBinaryExpression(move(LHS), prec::Comma);
@@ -218,7 +218,7 @@
 
 /// ParseAssignmentExpression - Parse an expr that doesn't include commas.
 ///
-ExprResult Parser::ParseAssignmentExpression() {
+ExprResult Parser::ParseAssignmentExpression(bool isInParens) {
   if (Tok.is(tok::code_completion)) {
     Actions.CodeCompleteOrdinaryName(getCurScope(), Sema::PCC_Expression);
     ConsumeCodeCompletionToken();
@@ -230,6 +230,12 @@
   ExprResult LHS(ParseCastExpression(false));
   if (LHS.isInvalid()) return move(LHS);
 
+  if (getLang().Eero && !isInParens &&  
+      Tok.isAtStartOfLine() && !InSystemHeader(Tok.getLocation())) {
+    InsertToken(tok::semi);
+    return LHS;
+  }
+
   return ParseRHSOfBinaryExpression(LHS.take(), prec::Assignment);
 }
 
@@ -637,6 +643,14 @@
       }
     }
 
+    if (getLang().Eero &&
+        BracketCount == 0 &&
+        (NextToken().is(tok::identifier) || NextToken().is(tok::colon)) && 
+        !NextToken().isAtStartOfLine() && !InSystemHeader(Tok.getLocation())) {
+      BracketCount = InferredBracketOffset;
+      return ParsePostfixExpressionSuffix(ParseObjCMessageExpression());
+    }
+
     // Consume the identifier so that we can see if it is followed by a '(' or
     // '.'.
     IdentifierInfo &II = *Tok.getIdentifierInfo();
@@ -676,9 +690,15 @@
     break;
   }
   case tok::char_constant:     // constant: character-constant
-    Res = Actions.ActOnCharacterConstant(Tok);
-    ConsumeToken();
-    break;
+    if (!getLang().Eero || InSystemHeader(Tok.getLocation())) {
+      Res = Actions.ActOnCharacterConstant(Tok);
+      ConsumeToken();
+      break;
+    } else {
+      Tok.setKind(tok::string_literal);
+      return ParseObjCAtExpression(Tok.getLocation());   
+    }
+      
   case tok::kw___func__:       // primary-expression: __func__ [C99 6.4.2.2]
   case tok::kw___FUNCTION__:   // primary-expression: __FUNCTION__ [GNU]
   case tok::kw___PRETTY_FUNCTION__:  // primary-expression: __P..Y_F..N__ [GNU]
@@ -917,10 +937,32 @@
     ConsumeCodeCompletionToken();
     return ParseCastExpression(isUnaryExpression, isAddressOfOperand, 
                                NotCastExpr, TypeOfCast);
+
+  case tok::kw_typedef: // should only get here with Eero "typedef XX... ..."
+    return ParsePrefixTypedef(ConsumeToken());
+
   case tok::l_square:
     // These can be followed by postfix-expr pieces.
-    if (getLang().ObjC1)
+    if (getLang().ObjC1 && !getLang().Eero)
       return ParsePostfixExpressionSuffix(ParseObjCMessageExpression());
+
+    // Eero logic to handle the optional outermost brackets when the complete expression
+    // started with an opening bracket.
+    if (getLang().Eero) {
+      ExprResult result = 
+          ParsePostfixExpressionSuffix(ParseObjCMessageExpression());
+
+      // Look for a selector on the same line as, and following, the closing bracket 
+      // from the previous message passing expression.
+      if (BracketCount == 0 && Tok.is(tok::identifier) && !Tok.isAtStartOfLine()) {
+        result = ParsePostfixExpressionSuffix(
+              ParseObjCMessageExpressionBody(SourceLocation(), 
+                                             SourceLocation(),
+                                             ParsedType(), 
+                                             result.take()));
+      }
+      return result;
+    }
     // FALL THROUGH.      
   default:
     NotCastExpr = true;
@@ -1513,7 +1555,7 @@
                                           move_arg(ArgExprs), TypeOfCast);
     }
   } else {
-    Result = ParseExpression();
+    Result = ParseExpression(true);
     ExprType = SimpleExpr;
     if (!Result.isInvalid() && Tok.is(tok::r_paren))
       Result = Actions.ActOnParenExpr(OpenLoc, Tok.getLocation(), Result.take());
@@ -1676,7 +1718,7 @@
 
   // If this block has arguments, parse them.  There is no ambiguity here with
   // the expression case, because the expression case requires a parameter list.
-  if (Tok.is(tok::l_paren)) {
+  if (Tok.is(tok::l_paren) && (!getLang().Eero || !Tok.isAtStartOfLine())) {
     ParseParenDeclarator(ParamInfo);
     // Parse the pieces after the identifier as if we had "int(...)".
     // SetIdentifier sets the source range end, but in this case we're past
@@ -1700,7 +1742,7 @@
 
     // Inform sema that we are starting a block.
     Actions.ActOnBlockArguments(ParamInfo, getCurScope());
-  } else if (!Tok.is(tok::l_brace)) {
+  } else if (!Tok.is(tok::l_brace) && (!getLang().Eero || !Tok.isAtStartOfLine())) {
     ParseBlockId();
   } else {
     // Otherwise, pretend we saw (void).
@@ -1723,6 +1765,10 @@
     Actions.ActOnBlockArguments(ParamInfo, getCurScope());
   }
 
+  // It's easiest if we just inject the inferred left brace for Eero
+  if (getLang().Eero) {
+    InsertToken(tok::l_brace);
+  }
 
   ExprResult Result(true);
   if (!Tok.is(tok::l_brace)) {
Index: lib/Parse/ParseStmt.cpp
===================================================================
--- lib/Parse/ParseStmt.cpp	(revision 123041)
+++ lib/Parse/ParseStmt.cpp	(working copy)
@@ -103,10 +103,41 @@
     ConsumeCodeCompletionToken();
     return ParseStatementOrDeclaration(OnlyStatement);
       
-  case tok::identifier:
-    if (NextToken().is(tok::colon)) { // C99 6.8.1: labeled-statement
-      // identifier ':' statement
-      return ParseLabeledStatement(AttrList.take());
+  case tok::identifier:      
+    if (!getLang().Eero) {
+      if (NextToken().is(tok::colon)) { // C99 6.8.1: labeled-statement
+        // identifier ':' statement
+        return ParseLabeledStatement(AttrList.take());
+      }
+    } else { // Eero does not support gotos/labels
+      if (GetLookAheadToken(1).is(tok::identifier) && 
+          GetLookAheadToken(2).is(tok::colon) && 
+          GetLookAheadToken(3).is(tok::equal)) { // support ":=" operator
+        Token objectClass = Tok;
+        ConsumeToken();
+        Token object = Tok;
+        ConsumeToken();
+        ConsumeToken(); // ":"
+        Token equals = Tok;
+        ConsumeToken(); // "="        
+        Tok.clearFlag(Token::StartOfLine); // ignore any newlines after the ":="
+        
+        if (Tok.isNot(tok::l_square)) { // support "Class object := message ..."
+          PP.EnterToken(Tok); // push forward new current token
+          PP.EnterToken(objectClass);
+        } else if (NextToken().is(tok::identifier)) {  // support "Class object := [message] ..."
+          Token l_square = Tok;
+          ConsumeBracket(); // "["
+          BracketCount--; // adjust since bracket will be restored
+          PP.EnterToken(Tok); // push forward new current token
+          PP.EnterToken(objectClass);
+          PP.EnterToken(l_square);
+        }
+        PP.EnterToken(equals);
+        PP.EnterToken(object);
+        PP.EnterToken(objectClass);          
+        ConsumeAnyToken(); // remove token that was pushed forward earlier
+      }
     }
     // PASS THROUGH.
 
@@ -136,14 +167,24 @@
         ConsumeToken();
       return StmtError();
     }
-    // Otherwise, eat the semicolon.
-    ExpectAndConsume(tok::semi, diag::err_expected_semi_after_expr);
+    if (!getLang().Eero) {
+      // Otherwise, eat the semicolon.
+      ExpectAndConsume(tok::semi, diag::err_expected_semi_after_expr);
+    } else if (Tok.is(tok::semi)) {
+      ConsumeToken();
+    }
     return Actions.ActOnExprStmt(Actions.MakeFullExpr(Expr.get()));
   }
 
   case tok::kw_case:                // C99 6.8.1: labeled-statement
+    if (getLang().Eero) { // auto-break all cases/defaults
+      Actions.ActOnBreakStmt(Tok.getLocation(), getCurScope());      
+    }
     return ParseCaseStatement(AttrList.take());
   case tok::kw_default:             // C99 6.8.1: labeled-statement
+    if (getLang().Eero) { // auto-break all cases/defaults
+      Actions.ActOnBreakStmt(Tok.getLocation(), getCurScope());
+    }
     return ParseDefaultStatement(AttrList.take());
 
   case tok::l_brace:                // C99 6.8.2: compound-statement
@@ -166,6 +207,11 @@
     return ParseForStatement(AttrList.take());
 
   case tok::kw_goto:                // C99 6.8.6.1: goto-statement
+    if (getLang().Eero) { // goto still a keyword, but use is forbidden in Eero
+      Diag(Tok, diag::err_goto_statement_forbidden);
+      SkipUntil(tok::identifier);
+      return StmtError();
+    }      
     Res = ParseGotoStatement(AttrList.take());
     SemiError = "goto";
     break;
@@ -200,7 +246,7 @@
   // If we reached this code, the statement must end in a semicolon.
   if (Tok.is(tok::semi)) {
     ConsumeToken();
-  } else if (!Res.isInvalid()) {
+  } else if (!Res.isInvalid() && !getLang().Eero) {
     // If the result was valid, then we do want to diagnose this.  Use
     // ExpectAndConsume to emit the diagnostic, even though we know it won't
     // succeed.
@@ -316,14 +362,22 @@
     
     ColonProtection.restore();
 
-    if (Tok.isNot(tok::colon)) {
-      Diag(Tok, diag::err_expected_colon_after) << "'case'";
-      SkipUntil(tok::colon);
-      return StmtError();
+    SourceLocation ColonLoc;
+    if (!getLang().Eero) {    
+      if (Tok.isNot(tok::colon)) {
+        Diag(Tok, diag::err_expected_colon_after) << "'case'";
+        SkipUntil(tok::colon);
+        return StmtError();
+      }
+      ColonLoc = ConsumeToken();
+    } else { // Eero
+      if (Tok.is(tok::colon)) {
+        ColonLoc = ConsumeToken();
+      } else if (Tok.isNot(tok::comma)) { // if not a colon or comma-separated list,
+        InsertToken(tok::l_brace);        // create a new scope
+      }
     }
 
-    SourceLocation ColonLoc = ConsumeToken();
-
     StmtResult Case =
       Actions.ActOnCaseStmt(CaseLoc, LHS.get(), DotDotDotLoc,
                             RHS.get(), ColonLoc);
@@ -346,7 +400,7 @@
     }
 
     // Handle all case statements.
-  } while (Tok.is(tok::kw_case));
+  } while (Tok.is(tok::kw_case) || (getLang().Eero && Tok.is(tok::comma)) );
 
   assert(!TopLevelCase.isInvalid() && "Should have parsed at least one case!");
 
@@ -385,15 +439,23 @@
 
   assert(Tok.is(tok::kw_default) && "Not a default stmt!");
   SourceLocation DefaultLoc = ConsumeToken();  // eat the 'default'.
+  
+  SourceLocation ColonLoc;
+  if (!getLang().Eero) {
+    if (Tok.isNot(tok::colon)) {
+      Diag(Tok, diag::err_expected_colon_after) << "'default'";
+      SkipUntil(tok::colon);
+      return StmtError();
+    }      
+    ColonLoc = ConsumeToken();
+  } else { // expect new scope if no colon
+    if (Tok.is(tok::colon)) {
+      ColonLoc = ConsumeToken();
+    } else {
+      InsertToken(tok::l_brace);
+    }
+  }  
 
-  if (Tok.isNot(tok::colon)) {
-    Diag(Tok, diag::err_expected_colon_after) << "'default'";
-    SkipUntil(tok::colon);
-    return StmtError();
-  }
-
-  SourceLocation ColonLoc = ConsumeToken();
-
   // Diagnose the common error "switch (X) {... default: }", which is not valid.
   if (Tok.is(tok::r_brace)) {
     Diag(Tok, diag::err_label_end_of_compound_statement);
@@ -451,7 +513,19 @@
   return ParseCompoundStatementBody(isStmtExpr);
 }
 
+/// File-private helper function used for Eero to determine if an indentation level
+/// is valid (previously established) for the current scope.
+static bool IsValidIndentation( unsigned column, 
+                                const std::deque<unsigned>& indentationPositions) {
+  if (column < indentationPositions.back())
+    return true;
+  else
+    return ( find( indentationPositions.begin(), 
+                   indentationPositions.end(), 
+                   column ) != indentationPositions.end() );
+}
 
+
 /// ParseCompoundStatementBody - Parse a sequence of statements and invoke the
 /// ActOnCompoundStmt action.  This expects the '{' to be the current token, and
 /// consume the '}' at the end of the block.  It does not manipulate the scope
@@ -468,7 +542,32 @@
 
   typedef StmtVector StmtsTy;
   StmtsTy Stmts(Actions);
+  bool newScope(true);
+
   while (Tok.isNot(tok::r_brace) && Tok.isNot(tok::eof)) {
+
+    if (getLang().Eero && Tok.isAtStartOfLine() && !InSystemHeader(LBraceLoc)) {      
+      unsigned column = Column(Tok.getLocation());      
+      if (!indentationPositions.empty()) {
+        if ((newScope && column <= indentationPositions.front()) ||
+            (!newScope && column != indentationPositions.front())) {          
+          if (column < indentationPositions.front() && 
+              IsValidIndentation(column,indentationPositions)) {
+            InsertToken(tok::r_brace);
+            break;          
+          } else {
+            Diag(Tok, diag::err_ambiguous_indentation);
+            SkipUntil(tok::semi);
+            return StmtError();
+          }
+        }
+      }
+      if (newScope) {
+        newScope = false;
+        indentationPositions.push_front(column);
+      }
+    }    
+    
     StmtResult R;
     if (Tok.isNot(tok::kw___extension__)) {
       R = ParseStatementOrDeclaration(false);
@@ -504,10 +603,14 @@
           continue;
         }
 
-        // FIXME: Use attributes?
-        // Eat the semicolon at the end of stmt and convert the expr into a
-        // statement.
-        ExpectAndConsume(tok::semi, diag::err_expected_semi_after_expr);
+        if (!getLang().Eero) {
+          // FIXME: Use attributes?
+          // Eat the semicolon at the end of stmt and convert the expr into a
+          // statement.
+          ExpectAndConsume(tok::semi, diag::err_expected_semi_after_expr);
+        } else if (Tok.is(tok::semi)) {
+          ConsumeToken();
+        }
         R = Actions.ActOnExprStmt(Actions.MakeFullExpr(Res.get()));
       }
     }
@@ -516,6 +619,10 @@
       Stmts.push_back(R.release());
   }
 
+  if (getLang().Eero && !indentationPositions.empty()) {
+    indentationPositions.pop_front();
+  }
+
   // We broke out of the while loop because we found a '}' or EOF.
   if (Tok.isNot(tok::r_brace)) {
     Diag(Tok, diag::err_expected_rbrace);
@@ -545,7 +652,11 @@
                                        bool ConvertToBoolean) {
   bool ParseError = false;
   
-  SourceLocation LParenLoc = ConsumeParen();
+  SourceLocation LParenLoc;  
+  if (!getLang().Eero || InSystemHeader(Loc)) {
+    LParenLoc = ConsumeParen();
+  }
+  
   if (getLang().CPlusPlus) 
     ParseError = ParseCXXCondition(ExprResult, DeclResult, Loc, 
                                    ConvertToBoolean);
@@ -570,8 +681,10 @@
       return true;
   }
 
-  // Otherwise the condition is valid or the rparen is present.
-  MatchRHSPunctuation(tok::r_paren, LParenLoc);
+  if (!getLang().Eero || InSystemHeader(Loc)) {
+    // Otherwise the condition is valid or the rparen is present.
+    MatchRHSPunctuation(tok::r_paren, LParenLoc);
+  }
   return false;
 }
 
@@ -590,7 +703,7 @@
   assert(Tok.is(tok::kw_if) && "Not an if stmt!");
   SourceLocation IfLoc = ConsumeToken();  // eat the 'if'.
 
-  if (Tok.isNot(tok::l_paren)) {
+  if (!getLang().Eero && Tok.isNot(tok::l_paren)) {
     Diag(Tok, diag::err_expected_lparen_after) << "if";
     SkipUntil(tok::semi);
     return StmtError();
@@ -620,6 +733,11 @@
 
   FullExprArg FullCondExp(Actions.MakeFullExpr(CondExp.get()));
 
+  // It's easiest if we just inject the inferred left brace
+  if (getLang().Eero && !InSystemHeader(IfLoc)) {
+    InsertToken(tok::l_brace);
+  }
+
   // C99 6.8.4p3 - In C99, the body of the if statement is a scope, even if
   // there is no compound stmt.  C90 does not have this clause.  We only do this
   // if the body isn't a compound statement to avoid push/pop in common cases.
@@ -654,25 +772,38 @@
   StmtResult ElseStmt;
 
   if (Tok.is(tok::kw_else)) {
-    ElseLoc = ConsumeToken();
-    ElseStmtLoc = Tok.getLocation();
 
-    // C99 6.8.4p3 - In C99, the body of the if statement is a scope, even if
-    // there is no compound stmt.  C90 does not have this clause.  We only do
-    // this if the body isn't a compound statement to avoid push/pop in common
-    // cases.
-    //
-    // C++ 6.4p1:
-    // The substatement in a selection-statement (each substatement, in the else
-    // form of the if statement) implicitly defines a local scope.
-    //
-    ParseScope InnerScope(this, Scope::DeclScope,
-                          C99orCXX && Tok.isNot(tok::l_brace));
+    if (!getLang().Eero || InSystemHeader(IfLoc) || 
+        Column(Tok.getLocation()) == Column(IfLoc)) {
 
-    ElseStmt = ParseStatement();
-    
-    // Pop the 'else' scope if needed.
-    InnerScope.Exit();
+      ElseLoc = ConsumeToken();
+      
+      // It's easiest if we just inject the inferred left brace
+      if (getLang().Eero &&
+          (Tok.isNot(tok::kw_if) || !Tok.isAtStartOfLine()) && 
+          !InSystemHeader(IfLoc)) {
+        InsertToken(tok::l_brace);
+      }
+
+      ElseStmtLoc = Tok.getLocation();
+
+      // C99 6.8.4p3 - In C99, the body of the if statement is a scope, even if
+      // there is no compound stmt.  C90 does not have this clause.  We only do
+      // this if the body isn't a compound statement to avoid push/pop in common
+      // cases.
+      //
+      // C++ 6.4p1:
+      // The substatement in a selection-statement (each substatement, in the else
+      // form of the if statement) implicitly defines a local scope.
+      //
+      ParseScope InnerScope(this, Scope::DeclScope,
+                            C99orCXX && Tok.isNot(tok::l_brace));
+
+      ElseStmt = ParseStatement();
+      
+      // Pop the 'else' scope if needed.
+      InnerScope.Exit();
+    }
   }
 
   IfScope.Exit();
@@ -713,7 +844,7 @@
   assert(Tok.is(tok::kw_switch) && "Not a switch stmt!");
   SourceLocation SwitchLoc = ConsumeToken();  // eat the 'switch'.
 
-  if (Tok.isNot(tok::l_paren)) {
+  if (!getLang().Eero && Tok.isNot(tok::l_paren)) {
     Diag(Tok, diag::err_expected_lparen_after) << "switch";
     SkipUntil(tok::semi);
     return StmtError();
@@ -759,7 +890,12 @@
       SkipUntil(tok::semi);
     return move(Switch);
   }
-  
+
+  // It's easiest if we just inject the inferred left brace
+  if (getLang().Eero && !InSystemHeader(SwitchLoc)) {
+    InsertToken(tok::l_brace);
+  }
+
   // C99 6.8.4p3 - In C99, the body of the switch statement is a scope, even if
   // there is no compound stmt.  C90 does not have this clause.  We only do this
   // if the body isn't a compound statement to avoid push/pop in common cases.
@@ -800,7 +936,7 @@
   SourceLocation WhileLoc = Tok.getLocation();
   ConsumeToken();  // eat the 'while'.
 
-  if (Tok.isNot(tok::l_paren)) {
+  if (!getLang().Eero && Tok.isNot(tok::l_paren)) {
     Diag(Tok, diag::err_expected_lparen_after) << "while";
     SkipUntil(tok::semi);
     return StmtError();
@@ -836,6 +972,11 @@
 
   FullExprArg FullCond(Actions.MakeFullExpr(Cond.get()));
 
+  // It's easiest if we just inject the inferred left brace
+  if (getLang().Eero && !InSystemHeader(WhileLoc)) {
+    InsertToken(tok::l_brace);
+  }
+
   // C99 6.8.5p5 - In C99, the body of the if statement is a scope, even if
   // there is no compound stmt.  C90 does not have this clause.  We only do this
   // if the body isn't a compound statement to avoid push/pop in common cases.
@@ -884,6 +1025,11 @@
 
   ParseScope DoScope(this, ScopeFlags);
 
+  // It's easiest if we just inject the inferred left brace
+  if (getLang().Eero && !InSystemHeader(DoLoc)) {
+    InsertToken(tok::l_brace);
+  }
+
   // C99 6.8.5p5 - In C99, the body of the if statement is a scope, even if
   // there is no compound stmt.  C90 does not have this clause. We only do this
   // if the body isn't a compound statement to avoid push/pop in common cases.
@@ -912,16 +1058,22 @@
   }
   SourceLocation WhileLoc = ConsumeToken();
 
-  if (Tok.isNot(tok::l_paren)) {
+  if (!getLang().Eero && Tok.isNot(tok::l_paren)) {
     Diag(Tok, diag::err_expected_lparen_after) << "do/while";
     SkipUntil(tok::semi, false, true);
     return StmtError();
   }
 
   // Parse the parenthesized condition.
-  SourceLocation LPLoc = ConsumeParen();
+  SourceLocation LPLoc;
+  if (!getLang().Eero || Tok.is(tok::l_paren)) {
+    LPLoc = ConsumeParen();
+  }
   ExprResult Cond = ParseExpression();
-  SourceLocation RPLoc = MatchRHSPunctuation(tok::r_paren, LPLoc);
+  SourceLocation RPLoc;
+  if (!getLang().Eero || LPLoc.isValid()) {
+    RPLoc = MatchRHSPunctuation(tok::r_paren, LPLoc);
+  }
   DoScope.Exit();
 
   if (Cond.isInvalid() || Body.isInvalid())
@@ -951,7 +1103,7 @@
   assert(Tok.is(tok::kw_for) && "Not a for stmt!");
   SourceLocation ForLoc = ConsumeToken();  // eat the 'for'.
 
-  if (Tok.isNot(tok::l_paren)) {
+  if (!getLang().Eero && Tok.isNot(tok::l_paren)) {
     Diag(Tok, diag::err_expected_lparen_after) << "for";
     SkipUntil(tok::semi);
     return StmtError();
@@ -983,7 +1135,10 @@
 
   ParseScope ForScope(this, ScopeFlags);
 
-  SourceLocation LParenLoc = ConsumeParen();
+  SourceLocation LParenLoc;  
+  if (!getLang().Eero || Tok.is(tok::l_paren)) {
+    LParenLoc = ConsumeParen();
+  }
   ExprResult Value;
 
   bool ForEach = false;
@@ -1091,8 +1246,16 @@
     }
   }
   // Match the ')'.
-  SourceLocation RParenLoc = MatchRHSPunctuation(tok::r_paren, LParenLoc);
+  SourceLocation RParenLoc;
+  if (LParenLoc.isValid()) {
+    RParenLoc = MatchRHSPunctuation(tok::r_paren, LParenLoc);
+  }
 
+  // It's easiest if we just inject the inferred left brace
+  if (getLang().Eero && !InSystemHeader(ForLoc)) {
+    InsertToken(tok::l_brace);
+  }
+
   // C99 6.8.5p5 - In C99, the body of the if statement is a scope, even if
   // there is no compound stmt.  C90 does not have this clause.  We only do this
   // if the body isn't a compound statement to avoid push/pop in common cases.
@@ -1206,7 +1369,7 @@
   SourceLocation ReturnLoc = ConsumeToken();  // eat the 'return'.
 
   ExprResult R;
-  if (Tok.isNot(tok::semi)) {
+  if (Tok.isNot(tok::semi) && !(getLang().Eero && Tok.isAtStartOfLine())) {
     if (Tok.is(tok::code_completion)) {
       Actions.CodeCompleteReturn(getCurScope());
       ConsumeCodeCompletionToken();
Index: lib/Parse/Parser.cpp
===================================================================
--- lib/Parse/Parser.cpp	(revision 123041)
+++ lib/Parse/Parser.cpp	(working copy)
@@ -182,6 +182,9 @@
   while (1) {
     // If we found one of the tokens, stop and return true.
     for (unsigned i = 0; i != NumToks; ++i) {
+      if (getLang().Eero && (StopAtSemi || Toks[i] == tok::semi))
+        if (Tok.isAtStartOfLine())
+          return true;      
       if (Tok.is(Toks[i])) {
         if (DontConsume) {
           // Noop, don't consume the token.
@@ -474,6 +477,13 @@
   case tok::kw_using:
   case tok::kw_namespace:
   case tok::kw_typedef:
+    if (getLang().Eero && 
+        GetLookAheadToken(1).is(tok::identifier) && 
+        GetLookAheadToken(2).is(tok::ellipsis) && 
+        GetLookAheadToken(3).is(tok::ellipsis) ) {
+      ParsePrefixTypedef(ConsumeToken());
+      break;
+    }   
   case tok::kw_template:
   case tok::kw_export:    // As in 'export template'
   case tok::kw_static_assert:
@@ -505,11 +515,18 @@
 
   default:
   dont_know:
-    // We can't tell whether this is a function-definition or declaration yet.
-    if (DS)
-      return ParseDeclarationOrFunctionDefinition(*DS, Attr.AttrList);
-    else
-      return ParseDeclarationOrFunctionDefinition(Attr.AttrList);
+    if (getLang().Eero &&
+        (Tok.is(tok::identifier) || Tok.is(tok::colon)) && 
+        !PendingObjCImpDecl.empty()) {
+      SingleDecl = ParseObjCMethodDefinition();
+      break;
+    } else {
+      // We can't tell whether this is a function-definition or declaration yet.
+      if (DS)
+        return ParseDeclarationOrFunctionDefinition(*DS, Attr.AttrList);
+      else
+        return ParseDeclarationOrFunctionDefinition(Attr.AttrList);
+    }
   }
 
   // This routine returns a DeclGroup, if the thing we parsed only contains a
