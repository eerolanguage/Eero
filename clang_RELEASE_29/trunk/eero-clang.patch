Index: include/clang/Frontend/FrontendAction.h
===================================================================
--- include/clang/Frontend/FrontendAction.h	(revision 129311)
+++ include/clang/Frontend/FrontendAction.h	(working copy)
@@ -32,6 +32,7 @@
   IK_CXX,
   IK_ObjC,
   IK_ObjCXX,
+  IK_Eero,  
   IK_PreprocessedC,
   IK_PreprocessedCXX,
   IK_PreprocessedObjC,
Index: include/clang/Basic/LangOptions.h
===================================================================
--- include/clang/Basic/LangOptions.h	(revision 129311)
+++ include/clang/Basic/LangOptions.h	(working copy)
@@ -47,6 +47,8 @@
   unsigned ObjCDefaultSynthProperties : 1; // Objective-C auto-synthesized properties.
   unsigned AppleKext         : 1;  // Allow apple kext features.
 
+  unsigned Eero              : 1;  // Eero (Objective-C 2 dialect) support enabled.
+
   unsigned PascalStrings     : 1;  // Allow Pascal strings
   unsigned WritableStrings   : 1;  // Allow writable strings
   unsigned ConstStrings      : 1;  // Add const qualifier to strings (-Wwrite-strings)
@@ -162,7 +164,7 @@
     Trigraphs = BCPLComment = Bool = DollarIdents = AsmPreprocessor = 0;
     GNUMode = GNUKeywords = ImplicitInt = Digraphs = 0;
     HexFloats = 0;
-    GC = ObjC1 = ObjC2 = ObjCNonFragileABI = ObjCNonFragileABI2 = 0;
+    GC = ObjC1 = ObjC2 = Eero = ObjCNonFragileABI = ObjCNonFragileABI2 = 0;
     AppleKext = 0;
     ObjCDefaultSynthProperties = 0;
     NoConstantCFStrings = 0; InlineVisibilityHidden = 0;
Index: include/clang/Basic/DiagnosticSemaKinds.td
===================================================================
--- include/clang/Basic/DiagnosticSemaKinds.td	(revision 129311)
+++ include/clang/Basic/DiagnosticSemaKinds.td	(working copy)
@@ -474,6 +474,10 @@
 def warn_unimplemented_protocol_method : Warning<
   "method in protocol not implemented">, InGroup<Protocol>;
 
+/// Eero (Objective-C) parser diagnostics
+def err_typecheck_case_incompatible : Error<
+  "case expression type does not match switch expression type %0">;
+
 // C++ declarations
 def err_static_assert_expression_is_not_constant : Error<
   "static_assert expression is not an integral constant expression">;
@@ -2750,6 +2754,10 @@
 def note_parameter_here : Note<
   "passing argument to parameter here">;
 
+// Eero casts object to/from primitive data types
+def err_unsupported_class_or_object_cast : Error<
+  "cast from %0 to %1 is not supported">;
+
 // C++ casts
 // These messages adhere to the TryCast pattern: %0 is an int specifying the
 // cast type, %1 is the source type, %2 is the destination type.
Index: include/clang/Basic/DiagnosticParseKinds.td
===================================================================
--- include/clang/Basic/DiagnosticParseKinds.td	(revision 129311)
+++ include/clang/Basic/DiagnosticParseKinds.td	(working copy)
@@ -286,6 +286,17 @@
   "declaration does not declare a parameter">;
 def err_no_matching_param : Error<"parameter named %0 is missing">;
 
+/// Eero (Objective-C) parser diagnostics
+def err_ambiguous_indentation : Error<"ambiguous indentation">;
+def err_goto_statement_forbidden : Error<"goto statement is forbidden">;
+def err_lbrace_not_allowed : Error<"'{' not allowed here">;
+def err_rbrace_not_allowed : Error<"'}' not allowed here">;
+def err_expected_pipe : Error<"expected '|'">;
+def err_expected_expression_after : Error<"expected expression after '%0'">;
+def err_expected_newline : Error<"expected newline">;
+def err_expected : Error<"expected %0">;
+
+
 /// C++ parser diagnostics
 def err_expected_unqualified_id : Error<
   "expected %select{identifier|unqualified-id}0">;
Index: include/clang/Sema/Scope.h
===================================================================
--- include/clang/Sema/Scope.h	(revision 129311)
+++ include/clang/Sema/Scope.h	(working copy)
@@ -16,6 +16,7 @@
 
 #include "clang/Basic/Diagnostic.h"
 #include "llvm/ADT/SmallPtrSet.h"
+#include "llvm/ADT/SmallVector.h"
 
 namespace clang {
 
@@ -123,6 +124,10 @@
   typedef llvm::SmallPtrSet<Decl *, 32> DeclSetTy;
   DeclSetTy DeclsInScope;
 
+  /// List of (ordered) Eero namespace-like prefixes
+  typedef llvm::SmallVector<const char *, 32> PrefixListTy;
+  PrefixListTy PrefixesInScope;
+
   /// Entity - The entity with which this scope is associated. For
   /// example, the entity of a class scope is the class itself, the
   /// entity of a function scope is a function, etc. This field is
@@ -212,6 +217,16 @@
     return DeclsInScope.count(D) != 0;
   }
 
+  /// Support for Eero namespace-like prefixes
+  typedef PrefixListTy::const_iterator prefix_iterator;
+  prefix_iterator prefix_begin() { return PrefixesInScope.begin(); }
+  prefix_iterator prefix_end()   { return PrefixesInScope.end(); }
+  bool prefix_empty()            const { return PrefixesInScope.empty(); }
+  //
+  void AddPrefix(const char *P) {
+    PrefixesInScope.push_back(P);
+  }
+
   void* getEntity() const { return Entity; }
   void setEntity(void *E) { Entity = E; }
 
@@ -311,6 +326,7 @@
     if (Flags & BlockScope)         BlockParent = this;
     if (Flags & TemplateParamScope) TemplateParamParent = this;
     DeclsInScope.clear();
+    PrefixesInScope.clear(); // Eero
     UsingDirectives.clear();
     Entity = 0;
     ErrorTrap.reset();
Index: include/clang/Sema/Sema.h
===================================================================
--- include/clang/Sema/Sema.h	(revision 129311)
+++ include/clang/Sema/Sema.h	(working copy)
@@ -1024,6 +1024,9 @@
                      Decl **Elements, unsigned NumElements,
                      Scope *S, AttributeList *Attr);
 
+  // Eero strict enums
+  void SetEnumAsStrict(Decl *EnumD);
+
   DeclContext *getContainingDC(DeclContext *DC);
 
   /// Set the current declaration context until it gets popped.
@@ -1053,7 +1056,8 @@
   NamedDecl *getCurFunctionOrMethodDecl();
 
   /// Add this decl to the scope shadowed decl chains.
-  void PushOnScopeChains(NamedDecl *D, Scope *S, bool AddToContext = true);
+  void PushOnScopeChains(NamedDecl *D, Scope *S, bool AddToContext = true, 
+                         bool AllowOverload = false); // added for Eero strict enums
 
   /// isDeclInScope - If 'Ctx' is a function/method, isDeclInScope returns true
   /// if 'D' is in Scope 'S', otherwise 'S' is ignored and isDeclInScope returns
@@ -1441,7 +1445,7 @@
                               RedeclarationKind Redecl
                                 = NotForRedeclaration);
   bool LookupName(LookupResult &R, Scope *S,
-                  bool AllowBuiltinCreation = false);
+                  bool AllowBuiltinCreation = false, bool doPrefixLookup = false);
   bool LookupQualifiedName(LookupResult &R, DeclContext *LookupCtx,
                            bool InUnqualifiedLookup = false);
   bool LookupParsedName(LookupResult &R, Scope *S, CXXScopeSpec *SS,
@@ -1792,6 +1796,25 @@
                                         Stmt *First, Expr *Second,
                                         SourceLocation RParenLoc, Stmt *Body);
 
+  /// Eero: "for <StrictEnumType> i in <StrictEnumType>" loop
+  StmtResult ActOnForStrictEnumStmt(SourceLocation ForLoc,
+                                    Stmt *First, 
+                                    ParsedType EnumTy, 
+                                    Stmt *Body);
+
+  /// Eero: "for <StrictEnumType> i in <StrictEnumConst> ... <StrictEnumConst>"
+  StmtResult ActOnForStrictEnumRangeStmt(SourceLocation ForLoc,
+                                         Stmt *First, 
+                                         Expr *EnumRangeStart,
+                                         Expr *EnumRangeEnd,
+                                         Stmt *Body);
+
+  /// Eero: "for <int> i in <NSRange>" loop
+  StmtResult ActOnForRangeStmt(SourceLocation ForColLoc,
+                               Stmt *First, 
+                               Expr *Second,
+                               Stmt *Body);
+
   StmtResult ActOnGotoStmt(SourceLocation GotoLoc,
                            SourceLocation LabelLoc,
                            LabelDecl *TheDecl);
@@ -2014,6 +2037,18 @@
   ExprResult CreateBuiltinArraySubscriptExpr(Expr *Base, SourceLocation LLoc,
                                              Expr *Idx, SourceLocation RLoc);
 
+  /// Eero: support object "[]" operators
+  ExprResult ActOnObjectSubscriptExpr(Scope *S, Expr *Base, 
+                                      SourceLocation LLoc,
+                                      Expr *Idx, SourceLocation RLoc);
+
+  /// Eero: support object "[]=" operator for integer or NSRange 
+  /// subscripts (arrays) and for object subscripts (KVC and dictionaries).
+  ExprResult ActOnObjectSubscriptAssignment(Scope *S,
+                                            Expr *Base, SourceLocation BLoc,
+                                            Expr *Idx, SourceLocation ILoc,
+                                            Expr *RHS, SourceLocation ELoc);
+
   ExprResult BuildMemberReferenceExpr(Expr *Base, QualType BaseType,
                                       SourceLocation OpLoc, bool IsArrow,
                                       CXXScopeSpec &SS,
@@ -2172,6 +2207,42 @@
   // __null
   ExprResult ActOnGNUNullExpr(SourceLocation TokenLoc);
 
+  // Eero binary operator extensions (TODO: move to private section)
+  ExprResult ActOnEeroBinOp(Scope *S, SourceLocation TokLoc,
+                            tok::TokenKind Kind, BinaryOperatorKind Opc,
+                            Expr *LHS, Expr *RHS);
+
+  // Eero strict enum support (TODO: move to private section)
+  Expr* ResolveStrictEnumExpr(QualType KnownType, Expr* OverloadedExpr);
+
+  // Eero: "cast" a built in numeric value (e.g. int or float) to an object type
+  ExprResult ActOnArithmeticTypeToObjectCast(Scope *S,
+                                             SourceLocation LParenLoc,
+                                             ParsedType ClassType, 
+                                             SourceLocation RParenLoc,
+                                             Expr* CastExpr);
+
+  // Eero: "cast" an object to a built in numeric value (e.g. int or float)
+  ExprResult ActOnObjectToArithmeticTypeCast(Scope *S,
+                                             SourceLocation LParenLoc,
+                                             QualType ArithmeticType, 
+                                             SourceLocation RParenLoc,
+                                             Expr* CastExpr);
+
+  // Eero: "cast" a C-style string (char*) to an object type
+  ExprResult ActOnCStringTypeToObjectCast(Scope *S,
+                                          SourceLocation LParenLoc,
+                                          ParsedType ClassType, 
+                                          SourceLocation RParenLoc,
+                                          Expr* CastExpr);
+
+  // Eero: "cast" an object to a C-style string (const char*)
+  ExprResult ActOnObjectToCStringTypeCast(Scope *S,
+                                          SourceLocation LParenLoc,
+                                          QualType CStringType, 
+                                          SourceLocation RParenLoc,
+                                          Expr* CastExpr);
+
   //===------------------------- "Block" Extension ------------------------===//
 
   /// ActOnBlockStart - This callback is invoked when a block literal is
@@ -4627,6 +4698,11 @@
                                   SourceLocation RBracLoc,
                                   MultiExprArg Args);
 
+  /// Eero support for namespace-like prefixes
+  void ActOnPrefixTypedef(Scope *CurScope,
+                          SourceLocation TypedefLoc,
+                          SourceLocation PrefixNameLoc,
+                          IdentifierInfo *PrefixName);
 
   enum PragmaOptionsAlignKind {
     POAK_Native,  // #pragma options align=native
Index: include/clang/AST/Decl.h
===================================================================
--- include/clang/AST/Decl.h	(revision 129311)
+++ include/clang/AST/Decl.h	(working copy)
@@ -2249,6 +2249,9 @@
   /// enumeration declared within the template.
   EnumDecl *InstantiatedFrom;
 
+  /// Eero -- true if a strict enumerated type
+  bool Strict;
+
   // The number of positive and negative bits required by the
   // enumerators are stored in the SubclassBits field.
   enum {
@@ -2260,7 +2263,7 @@
            IdentifierInfo *Id, EnumDecl *PrevDecl, SourceLocation StartL,
            bool Scoped, bool ScopedUsingClassTag, bool Fixed)
     : TagDecl(Enum, TTK_Enum, DC, L, Id, PrevDecl, StartL),
-      InstantiatedFrom(0) {
+      InstantiatedFrom(0), Strict(false) {
     assert(Scoped || !ScopedUsingClassTag);
     IntegerType = (const Type*)0;
     NumNegativeBits = 0;
@@ -2404,6 +2407,10 @@
 
   void setInstantiationOfMemberEnum(EnumDecl *IF) { InstantiatedFrom = IF; }
 
+  // Eero
+  bool isStrict() const { return Strict; }
+  void setStrict(bool strict) { Strict = strict; }
+
   static bool classof(const Decl *D) { return classofKind(D->getKind()); }
   static bool classof(const EnumDecl *D) { return true; }
   static bool classofKind(Kind K) { return K == Enum; }
Index: include/clang/AST/Type.h
===================================================================
--- include/clang/AST/Type.h	(revision 129311)
+++ include/clang/AST/Type.h	(working copy)
@@ -1182,6 +1182,7 @@
   /// isComplexIntegerType() can be used to test for complex integers.
   bool isIntegerType() const;     // C99 6.2.5p17 (int, char, bool, enum)
   bool isEnumeralType() const;
+  bool isStrictEnumeralType() const; // Eero-specific
   bool isBooleanType() const;
   bool isCharType() const;
   bool isWideCharType() const;
Index: include/clang/Driver/Types.def
===================================================================
--- include/clang/Driver/Types.def	(revision 129311)
+++ include/clang/Driver/Types.def	(working copy)
@@ -44,6 +44,7 @@
 TYPE("cl",                       CL,           PP_C,            0,       "u")
 TYPE("objective-c-cpp-output",   PP_ObjC,      INVALID,         "mi",    "u")
 TYPE("objective-c",              ObjC,         PP_ObjC,         0,       "u")
+TYPE("eero",                     Eero,         PP_ObjC,         0,       "u")
 TYPE("c++-cpp-output",           PP_CXX,       INVALID,         "ii",    "u")
 TYPE("c++",                      CXX,          PP_CXX,          0,       "u")
 TYPE("objective-c++-cpp-output", PP_ObjCXX,    INVALID,         "mii",   "u")
Index: include/clang/Parse/Parser.h
===================================================================
--- include/clang/Parse/Parser.h	(revision 129311)
+++ include/clang/Parse/Parser.h	(working copy)
@@ -150,6 +150,9 @@
   /// Factory object for creating AttributeList objects.
   AttributeList::Factory AttrFactory;
 
+  /// Used for Eero (Python-like) indentation tracking.
+  std::deque<unsigned> indentationPositions;
+
 public:
   Parser(Preprocessor &PP, Sema &Actions);
   ~Parser();
@@ -542,6 +545,28 @@
   /// ExitScope - Pop a scope off the scope stack.
   void ExitScope();
 
+
+  /// Convenience function used with Eero
+  bool InSystemHeader(const SourceLocation& Loc) {
+    if (PP.isInPrimaryFile())
+      return false;
+    else 
+      return PP.getSourceManager().isInSystemHeader(Loc);
+  }
+
+  /// Convenience function used with Eero
+  unsigned Column(const SourceLocation& Loc) {
+    return PP.getSourceManager().getInstantiationColumnNumber(Loc);
+  }
+
+  /// Convenience function used with Eero
+  void InsertToken(const tok::TokenKind tokenKind) {
+    PP.EnterToken(Tok);
+    Tok.setKind(tokenKind);
+    Tok.setLength(0);
+    Tok.setIdentifierInfo(0);
+  }
+
   //===--------------------------------------------------------------------===//
   // Diagnostic Emission and Error recovery.
 
@@ -1197,6 +1222,11 @@
   bool ParseObjCXXMessageReceiver(bool &IsExpr, void *&TypeOrExpr);
 
   //===--------------------------------------------------------------------===//
+  // Eero-specific Expressions
+  ExprResult ParsePrefixTypedef(SourceLocation TypedefLoc);
+  ExprResult ParseRangeIfPresent(ExprResult LHS);
+
+  //===--------------------------------------------------------------------===//
   // C99 6.8: Statements and Blocks.
 
   StmtResult ParseStatement() {
@@ -1205,6 +1235,8 @@
   }
   StmtResult ParseStatementOrDeclaration(StmtVector& Stmts,
                                          bool OnlyStatement = false);
+  // Eero support for ":=" operator
+  void ParseColonEqualOperatorIfPresent();
   StmtResult ParseLabeledStatement(ParsedAttributes &Attr);
   StmtResult ParseCaseStatement(ParsedAttributes &Attr);
   StmtResult ParseDefaultStatement(ParsedAttributes &Attr);
@@ -1300,8 +1332,8 @@
 
   void ParseEnumSpecifier(SourceLocation TagLoc, DeclSpec &DS,
                 const ParsedTemplateInfo &TemplateInfo = ParsedTemplateInfo(),
-                AccessSpecifier AS = AS_none);
-  void ParseEnumBody(SourceLocation StartLoc, Decl *TagDecl);
+                AccessSpecifier AS = AS_none, bool Strict=false);
+  void ParseEnumBody(SourceLocation StartLoc, Decl *TagDecl, bool Strict=false);
   void ParseStructUnionBody(SourceLocation StartLoc, unsigned TagType,
                             Decl *TagDecl);
 
Index: lib/Frontend/FrontendActions.cpp
===================================================================
--- lib/Frontend/FrontendActions.cpp	(revision 129311)
+++ lib/Frontend/FrontendActions.cpp	(working copy)
@@ -196,6 +196,7 @@
   case IK_C:
   case IK_CXX:
   case IK_ObjC:
+  case IK_Eero:
   case IK_ObjCXX:
   case IK_OpenCL:
     break;
Index: lib/Frontend/CompilerInvocation.cpp
===================================================================
--- lib/Frontend/CompilerInvocation.cpp	(revision 129311)
+++ lib/Frontend/CompilerInvocation.cpp	(working copy)
@@ -301,6 +301,7 @@
   case IK_CXX:               return "c++";
   case IK_LLVM_IR:           return "ir";
   case IK_ObjC:              return "objective-c";
+  case IK_Eero:              return "eero";
   case IK_ObjCXX:            return "objective-c++";
   case IK_OpenCL:            return "cl";
   case IK_PreprocessedC:     return "cpp-output";
@@ -1151,6 +1152,7 @@
       .Case("cl", IK_OpenCL)
       .Case("c++", IK_CXX)
       .Case("objective-c", IK_ObjC)
+      .Case("eero", IK_Eero)
       .Case("objective-c++", IK_ObjCXX)
       .Case("cpp-output", IK_PreprocessedC)
       .Case("assembler-with-cpp", IK_Asm)
@@ -1261,11 +1263,17 @@
   if (IK == IK_Asm) {
     Opts.AsmPreprocessor = 1;
   } else if (IK == IK_ObjC ||
+             IK == IK_Eero ||
              IK == IK_ObjCXX ||
              IK == IK_PreprocessedObjC ||
              IK == IK_PreprocessedObjCXX) {
     Opts.ObjC1 = Opts.ObjC2 = 1;
   }
+  
+  if (IK == IK_Eero) {
+    Opts.Eero = 1;
+    Opts.CXXOperatorNames = 1;
+  }
 
   if (LangStd == LangStandard::lang_unspecified) {
     // Based on the base language, pick one.
@@ -1281,6 +1289,7 @@
     case IK_C:
     case IK_PreprocessedC:
     case IK_ObjC:
+    case IK_Eero:
     case IK_PreprocessedObjC:
       LangStd = LangStandard::lang_gnu99;
       break;
@@ -1317,7 +1326,8 @@
   Opts.Bool = Opts.OpenCL || Opts.CPlusPlus;
 
   Opts.GNUKeywords = Opts.GNUMode;
-  Opts.CXXOperatorNames = Opts.CPlusPlus;
+  if (Opts.CPlusPlus)
+    Opts.CXXOperatorNames = 1;
 
   // Mimicing gcc's behavior, trigraphs are only enabled if -trigraphs
   // is specified, or -std is set to a conforming mode.
Index: lib/Frontend/FrontendOptions.cpp
===================================================================
--- lib/Frontend/FrontendOptions.cpp	(revision 129311)
+++ lib/Frontend/FrontendOptions.cpp	(working copy)
@@ -19,6 +19,7 @@
     .Case("i", IK_PreprocessedC)
     .Case("ii", IK_PreprocessedCXX)
     .Case("m", IK_ObjC)
+    .Case("ero", IK_Eero)
     .Case("mi", IK_PreprocessedObjC)
     .Cases("mm", "M", IK_ObjCXX)
     .Case("mii", IK_PreprocessedObjCXX)
Index: lib/Basic/Version.cpp
===================================================================
--- lib/Basic/Version.cpp	(revision 129311)
+++ lib/Basic/Version.cpp	(working copy)
@@ -77,7 +77,7 @@
   OS << CLANG_VENDOR;
 #endif
   OS << "clang version " CLANG_VERSION_STRING " ("
-     << getClangFullRepositoryVersion() << ')';
+     << getClangFullRepositoryVersion() << ')' << " (Eero support added)";
 
   // If vendor supplied, include the base LLVM version as well.
 #ifdef CLANG_VENDOR
Index: lib/Sema/SemaDeclObjC.cpp
===================================================================
--- lib/Sema/SemaDeclObjC.cpp	(revision 129311)
+++ lib/Sema/SemaDeclObjC.cpp	(working copy)
@@ -1751,9 +1751,15 @@
     // Methods cannot return interface types. All ObjC objects are
     // passed by reference.
     if (resultDeclType->isObjCObjectType()) {
-      Diag(MethodLoc, diag::err_object_cannot_be_passed_returned_by_value)
-        << 0 << resultDeclType;
-      return 0;
+      if (!getLangOptions().Eero) {      
+        Diag(MethodLoc, diag::err_object_cannot_be_passed_returned_by_value)
+          << 0 << resultDeclType;
+        return 0;
+      } else { // make it a pointer instead of flagging it an error
+        QualType objectType = Context.getObjCObjectType( resultDeclType, 0, 0 );  
+        QualType pointerType = Context.getObjCObjectPointerType(objectType);
+        resultDeclType = pointerType;                    
+      }
     }
   } else // get the type for "id".
     resultDeclType = Context.getObjCIdType();
@@ -1803,10 +1809,16 @@
                             SC_None, SC_None, 0);
 
     if (ArgType->isObjCObjectType()) {
-      Diag(ArgInfo[i].NameLoc,
-           diag::err_object_cannot_be_passed_returned_by_value)
-        << 1 << ArgType;
-      Param->setInvalidDecl();
+      if (!getLangOptions().Eero) {
+        Diag(ArgInfo[i].NameLoc,
+             diag::err_object_cannot_be_passed_returned_by_value)
+          << 1 << ArgType;
+        Param->setInvalidDecl();
+      } else { // make it a pointer instead of flagging it an error
+        QualType objectType = Context.getObjCObjectType( ArgType, 0, 0 );  
+        QualType pointerType = Context.getObjCObjectPointerType(objectType);
+        Param->setType(pointerType);                    
+      }
     }
 
     Param->setObjCDeclQualifier(
@@ -1967,8 +1979,12 @@
   } else if (T->isDependentType()) {
     // Okay: we don't know what this type will instantiate to.
   } else if (!T->isObjCObjectPointerType()) {
-    Invalid = true;
-    Diag(NameLoc ,diag::err_catch_param_not_objc_type);
+    if (!getLangOptions().Eero || !T->isObjCObjectType()) {
+      Invalid = true;
+      Diag(NameLoc ,diag::err_catch_param_not_objc_type);
+    } else { // make it a pointer instead of flagging it an error
+      T = Context.getObjCObjectPointerType(T);
+    }
   } else if (T->isObjCQualifiedIdType()) {
     Invalid = true;
     Diag(NameLoc, diag::err_illegal_qualifiers_on_catch_parm);
@@ -2080,3 +2096,16 @@
   }
   return;
 }
+
+/// Eero support for namespace-like prefixes
+
+void Sema::ActOnPrefixTypedef(Scope *CurScope,
+                              SourceLocation TypedefLoc,
+                              SourceLocation PrefixNameLoc,
+                              IdentifierInfo *PrefixName) {
+
+    // TODO: add error checking for duplicate prefixes in same scope?
+    
+    CurScope->AddPrefix(PrefixName->getNameStart());
+}
+
Index: lib/Sema/SemaDecl.cpp
===================================================================
--- lib/Sema/SemaDecl.cpp	(revision 129311)
+++ lib/Sema/SemaDecl.cpp	(working copy)
@@ -131,7 +131,7 @@
     }
   } else {
     // Perform unqualified name lookup.
-    LookupName(Result, S);
+    LookupName(Result, S,false,true);
   }
   
   NamedDecl *IIDecl = 0;
@@ -454,7 +454,7 @@
 }
 
 /// Add this decl to the scope shadowed decl chains.
-void Sema::PushOnScopeChains(NamedDecl *D, Scope *S, bool AddToContext) {
+void Sema::PushOnScopeChains(NamedDecl *D, Scope *S, bool AddToContext, bool AllowOverload) {
   // Move up the scope chain until we find the nearest enclosing
   // non-transparent context. The declaration will be introduced into this
   // scope.
@@ -479,16 +479,19 @@
       cast<FunctionDecl>(D)->isFunctionTemplateSpecialization())
     return;
 
-  // If this replaces anything in the current scope, 
-  IdentifierResolver::iterator I = IdResolver.begin(D->getDeclName()),
-                               IEnd = IdResolver.end();
-  for (; I != IEnd; ++I) {
-    if (S->isDeclScope(*I) && D->declarationReplaces(*I)) {
-      S->RemoveDecl(*I);
-      IdResolver.RemoveDecl(*I);
+  IdentifierResolver::iterator I, IEnd;
+  if (!AllowOverload) { // Eero strict enums allow overloading of member constants
+    // If this replaces anything in the current scope, 
+    I = IdResolver.begin(D->getDeclName());
+    IEnd = IdResolver.end();
+    for (; I != IEnd; ++I) {
+      if (S->isDeclScope(*I) && D->declarationReplaces(*I)) {
+        S->RemoveDecl(*I);
+        IdResolver.RemoveDecl(*I);
 
-      // Should only need to replace one decl.
-      break;
+        // Should only need to replace one decl.
+        break;
+      }
     }
   }
 
@@ -3375,8 +3378,30 @@
   QualType T = NewVD->getType();
 
   if (T->isObjCObjectType()) {
-    Diag(NewVD->getLocation(), diag::err_statically_allocated_object);
-    return NewVD->setInvalidDecl();
+    if (!getLangOptions().Eero) {
+      Diag(NewVD->getLocation(), diag::err_statically_allocated_object);
+      return NewVD->setInvalidDecl();
+    } else {
+      QualType objectType = Context.getObjCObjectType( T, 0, 0 );  
+      // If const qualifier is present, remove it from the pointed-to data,
+      // and add it to the variable itself. This is to make something like
+      //      const String string = 'abc'
+      // equivalent to
+      //      typedef NSString* StringType
+      //      const StringType string = 'abc'
+      bool isConst;
+      if (objectType.isLocalConstQualified()) {
+        isConst = true;
+        objectType.removeLocalConst();
+      } else {
+        isConst = false;
+      }      
+      QualType pointerType = Context.getObjCObjectPointerType(objectType);
+      if (isConst) {
+        pointerType.addConst();
+      }
+      NewVD->setType(pointerType);                    
+    }
   }
 
   // Emit an error if an address space was applied to decl with local storage.
@@ -6728,7 +6753,8 @@
 
   // C99 6.7.2.1p4 - verify the field type.
   // C++ 9.6p3: A bit-field shall have integral or enumeration type.
-  if (!FieldTy->isDependentType() && !FieldTy->isIntegralOrEnumerationType()) {
+  if ((!FieldTy->isDependentType() && !FieldTy->isIntegralOrEnumerationType()) ||
+      (getLangOptions().Eero && BitWidth->getType()->isStrictEnumeralType())) {
     // Handle incomplete types with specific error.
     if (RequireCompleteType(FieldLoc, FieldTy, diag::err_field_incomplete))
       return true;
@@ -7464,10 +7490,16 @@
         Record->setHasObjectMember(true);
     } else if (FDTy->isObjCObjectType()) {
       /// A field cannot be an Objective-c object
-      Diag(FD->getLocation(), diag::err_statically_allocated_object);
-      FD->setInvalidDecl();
-      EnclosingDecl->setInvalidDecl();
-      continue;
+      if (!getLangOptions().Eero) {
+        Diag(FD->getLocation(), diag::err_statically_allocated_object);
+        FD->setInvalidDecl();
+        EnclosingDecl->setInvalidDecl();
+        continue;
+      } else {
+        QualType objectType = Context.getObjCObjectType( FD->getType(), 0, 0 );  
+        QualType pointerType = Context.getObjCObjectPointerType(objectType);
+        FD->setType(pointerType);                 
+      }
     } else if (getLangOptions().ObjC1 &&
                getLangOptions().getGCMode() != LangOptions::NonGC &&
                Record &&
@@ -7819,12 +7851,29 @@
     assert((getLangOptions().CPlusPlus || !isa<TagDecl>(PrevDecl)) &&
            "Received TagDecl when not in C++!");
     if (!isa<TagDecl>(PrevDecl) && isDeclInScope(PrevDecl, CurContext, S)) {
-      if (isa<EnumConstantDecl>(PrevDecl))
-        Diag(IdLoc, diag::err_redefinition_of_enumerator) << Id;
-      else
+      bool overloadAllowed = false;
+      if (isa<EnumConstantDecl>(PrevDecl)) {
+        if (getLangOptions().Eero) { 
+          // Overloaded constants are not allowed within a strict enum type,
+          // nor are non-strict enum constants eligible for overloading.
+          QualType ThisType = Context.getTypeDeclType(TheEnumDecl);
+          if (ThisType->isStrictEnumeralType()) {
+            QualType PrevType = cast<EnumConstantDecl>(PrevDecl)->getType();
+            if (PrevType->isStrictEnumeralType() && PrevType != ThisType) {
+              overloadAllowed = true;
+            }
+          }
+        }
+        if (!overloadAllowed) {
+          Diag(IdLoc, diag::err_redefinition_of_enumerator) << Id;
+        }
+      } else {
         Diag(IdLoc, diag::err_redefinition) << Id;
-      Diag(PrevDecl->getLocation(), diag::note_previous_definition);
-      return 0;
+      }
+      if (!overloadAllowed) {
+        Diag(PrevDecl->getLocation(), diag::note_previous_definition);
+        return 0;
+      }
     }
   }
 
@@ -7848,7 +7897,12 @@
 
     // Register this decl in the current scope stack.
     New->setAccess(TheEnumDecl->getAccess());
-    PushOnScopeChains(New, S);
+    if (!getLangOptions().Eero || 
+        !Context.getTypeDeclType(TheEnumDecl)->isStrictEnumeralType()) {
+      PushOnScopeChains(New, S);
+    } else {
+      PushOnScopeChains(New, S, true, true /*AllowOverload*/);
+    }
   }
 
   return New;
@@ -8055,7 +8109,8 @@
                                                 ECD->getInitExpr(),
                                                 /*base paths*/ 0,
                                                 VK_RValue));
-    if (getLangOptions().CPlusPlus)
+    if (getLangOptions().CPlusPlus || 
+        (getLangOptions().Eero && EnumType->isStrictEnumeralType()))
       // C++ [dcl.enum]p4: Following the closing brace of an
       // enum-specifier, each enumerator has the type of its
       // enumeration.
@@ -8068,6 +8123,12 @@
                            NumPositiveBits, NumNegativeBits);
 }
 
+// Eero strict enums
+void Sema::SetEnumAsStrict(Decl *EnumD) {
+  EnumDecl* enumDecl = cast<EnumDecl>(EnumD);
+  enumDecl->setStrict(true);
+}
+
 Decl *Sema::ActOnFileScopeAsmDecl(Expr *expr,
                                   SourceLocation StartLoc,
                                   SourceLocation EndLoc) {
Index: lib/Sema/SemaType.cpp
===================================================================
--- lib/Sema/SemaType.cpp	(revision 129311)
+++ lib/Sema/SemaType.cpp	(working copy)
@@ -1114,8 +1114,9 @@
   // C99 6.7.5.2p1: The size expression shall have integer type.
   // TODO: in theory, if we were insane, we could allow contextual
   // conversions to integer type here.
-  if (ArraySize && !ArraySize->isTypeDependent() &&
-      !ArraySize->getType()->isIntegralOrUnscopedEnumerationType()) {
+  if (ArraySize && ((!ArraySize->isTypeDependent() &&
+      !ArraySize->getType()->isIntegralOrUnscopedEnumerationType()) ||
+      (getLangOptions().Eero && ArraySize->getType()->isStrictEnumeralType()))) {
     Diag(ArraySize->getLocStart(), diag::err_array_size_non_int)
       << ArraySize->getType() << ArraySize->getSourceRange();
     return QualType();
Index: lib/Sema/SemaStmt.cpp
===================================================================
--- lib/Sema/SemaStmt.cpp	(revision 129311)
+++ lib/Sema/SemaStmt.cpp	(working copy)
@@ -190,6 +190,49 @@
                     SourceLocation ColonLoc) {
   assert((LHSVal != 0) && "missing expression in case statement");
 
+  // Handle strict enum values
+  if (getLangOptions().Eero && !getCurFunction()->SwitchStack.empty()) {
+    QualType switchCondType = 
+        getCurFunction()->SwitchStack.back()->getCond()->getType();
+
+    if (switchCondType->isStrictEnumeralType()) {
+
+      Expr* errExpr = 0;
+
+      if (LHSVal->getType()->isSpecificBuiltinType(BuiltinType::Overload)) {
+        Expr* resolvedExpr = ResolveStrictEnumExpr(switchCondType, LHSVal);
+        if (resolvedExpr) {
+          // TODO: free expr?
+          LHSVal = resolvedExpr;
+        } else {
+          errExpr = LHSVal;
+        }        
+      } else if (LHSVal->getType()->getCanonicalTypeUnqualified() !=
+                 switchCondType->getCanonicalTypeUnqualified()) {
+        errExpr = LHSVal;
+      }
+      
+      if (RHSVal && RHSVal->getType()->isSpecificBuiltinType(BuiltinType::Overload)) {
+        Expr* resolvedExpr = ResolveStrictEnumExpr(switchCondType, RHSVal);
+        if (resolvedExpr) {
+          // TODO: free expr?
+          RHSVal = resolvedExpr;
+        } else {
+          errExpr = RHSVal;
+        }        
+      } else if (RHSVal && RHSVal->getType()->getCanonicalTypeUnqualified() !=
+                           switchCondType->getCanonicalTypeUnqualified()) {
+        errExpr = RHSVal;
+      }
+
+      if (errExpr) {
+        Diag(CaseLoc, diag::err_typecheck_case_incompatible) << 
+            switchCondType << errExpr->getSourceRange();
+        return StmtError();
+      }
+    }
+  }
+
   // C99 6.8.4.2p3: The expression shall be an integer constant.
   // However, GCC allows any evaluatable integer expression.
   if (!LHSVal->isTypeDependent() && !LHSVal->isValueDependent() &&
@@ -936,6 +979,352 @@
   return Owned(static_cast<Stmt*>(Result.get()));
 }
 
+
+/// Eero: "for <StrictEnumType> i in <StrictEnumType>" loop
+StmtResult 
+Sema::ActOnForStrictEnumStmt(SourceLocation ForLoc,
+                             Stmt *First, 
+                             ParsedType EnumTy, 
+                             Stmt *Body) {
+
+  assert(getLangOptions().Eero && First &&
+         "The parser shouldn't call this if there is no expr before 'in'.");
+
+  QualType FirstType;
+  bool hasDeclaration;
+  Expr* varExpr;
+  if (DeclStmt *DS = dyn_cast<DeclStmt>(First)) {
+    if (!DS->isSingleDecl())
+      return StmtError(Diag((*DS->decl_begin())->getLocation(),
+                       diag::err_toomany_element_decls));
+
+    hasDeclaration = true;  
+    Decl *D = DS->getSingleDecl();
+    FirstType = cast<ValueDecl>(D)->getType();
+    // C99 6.8.5p3: The declaration part of a 'for' statement shall only
+    // declare identifiers for objects having storage class 'auto' or
+    // 'register'.
+    VarDecl *VD = cast<VarDecl>(D);
+    if (VD->isLocalVarDecl() && !VD->hasLocalStorage())
+      return StmtError(Diag(VD->getLocation(),
+                            diag::err_non_variable_decl_in_for));
+
+    ValueDecl *valDecl = cast<ValueDecl>(D);
+    varExpr = new (Context) DeclRefExpr(valDecl, FirstType, VK_LValue, SourceLocation());
+  } else {
+    varExpr = cast<Expr>(First);
+    if (!varExpr->isTypeDependent() && !varExpr->isLValue()) {
+      return StmtError(Diag(First->getLocStart(),
+                 diag::err_selector_element_not_lvalue)
+        << First->getSourceRange());
+    }
+    hasDeclaration = false;
+    FirstType = static_cast<Expr*>(First)->getType();
+  }
+
+  if (!FirstType->isStrictEnumeralType())
+      Diag(ForLoc, diag::err_selector_element_type)
+        << FirstType << First->getSourceRange();
+
+  TypeSourceInfo *TInfo;
+  QualType Ty = GetTypeFromParser(EnumTy, &TInfo);
+
+  if (!Ty->isStrictEnumeralType())
+    return StmtError(Diag(ForLoc, diag::err_selector_element_type) << Ty);
+
+  EnumDecl* enumDecl = Ty->getAs<EnumType>()->getDecl();
+  EnumDecl::enumerator_iterator enumBegin = enumDecl->enumerator_begin();
+  EnumDecl::enumerator_iterator enumEnd = enumDecl->enumerator_end();
+
+  // Empty strict enums are not allowed, so it's safe to proceed
+
+  Expr* beginExpr = 
+      new (Context) DeclRefExpr(*enumBegin, Ty, VK_RValue, SourceLocation());
+
+  // Get to the last value (no "iter--" available)
+  ValueDecl* enumLastValue = 0;
+  for ( EnumDecl::enumerator_iterator enumIt = enumBegin;
+        enumIt != enumEnd; 
+        enumIt++ ) {
+    enumLastValue = *enumIt;
+  }
+
+  Expr* endExpr = 
+      new (Context) DeclRefExpr(enumLastValue, Ty, VK_RValue, SourceLocation());
+
+  ExprResult assignExpr = 
+      CreateBuiltinBinOp(First->getLocStart(),
+                         BO_Assign,
+                         varExpr,
+                         beginExpr);
+
+  Stmt* initStmt; 
+  if (hasDeclaration) {
+    Stmt* statements[2] = { First, assignExpr.take() };
+    initStmt = new (Context) CompoundStmt(Context,
+                                          statements,
+                                          2,
+                                          SourceLocation(),
+                                          SourceLocation());
+  } else {
+    initStmt = assignExpr.take();
+  }
+
+  ExprResult condExpr = CreateBuiltinBinOp(SourceLocation(),
+                                           BO_LE,
+                                           varExpr,
+                                           endExpr );
+
+  ExprResult incrExpr = CreateBuiltinUnaryOp(SourceLocation(),
+                                             UO_PostInc,
+                                             varExpr );
+
+  return Owned(new (Context) ForStmt(Context, initStmt, 
+                                     condExpr.take(), 0, 
+                                     incrExpr.take(), Body, ForLoc, 
+                                     SourceLocation(), SourceLocation()));
+}
+
+/// Eero: "for <StrictEnumType> i in <StrictEnumType>" loop
+StmtResult 
+Sema::ActOnForStrictEnumRangeStmt(SourceLocation ForLoc,
+                                  Stmt *First, 
+                                  Expr *EnumRangeStart,
+                                  Expr *EnumRangeEnd,
+                                  Stmt *Body) {
+
+  assert(getLangOptions().Eero && First &&
+         "The parser shouldn't call this if there is no expr before 'in'.");
+
+  QualType FirstType;
+  bool hasDeclaration;
+  Expr* varExpr;
+  if (DeclStmt *DS = dyn_cast<DeclStmt>(First)) {
+    if (!DS->isSingleDecl())
+      return StmtError(Diag((*DS->decl_begin())->getLocation(),
+                       diag::err_toomany_element_decls));
+
+    hasDeclaration = true;  
+    Decl *D = DS->getSingleDecl();
+    FirstType = cast<ValueDecl>(D)->getType();
+    // C99 6.8.5p3: The declaration part of a 'for' statement shall only
+    // declare identifiers for objects having storage class 'auto' or
+    // 'register'.
+    VarDecl *VD = cast<VarDecl>(D);
+    if (VD->isLocalVarDecl() && !VD->hasLocalStorage())
+      return StmtError(Diag(VD->getLocation(),
+                            diag::err_non_variable_decl_in_for));
+
+    ValueDecl *valDecl = cast<ValueDecl>(D);
+    varExpr = new (Context) DeclRefExpr(valDecl, FirstType, VK_LValue, SourceLocation());
+  } else {
+    varExpr = cast<Expr>(First);
+    if (!varExpr->isTypeDependent() && !varExpr->isLValue()) {
+      return StmtError(Diag(First->getLocStart(),
+                 diag::err_selector_element_not_lvalue)
+        << First->getSourceRange());
+    }
+    hasDeclaration = false;
+    FirstType = static_cast<Expr*>(First)->getType();
+  }
+
+  // Make sure first part is a strict enum variable or variable declaration
+  if (!FirstType->isStrictEnumeralType())
+      Diag(ForLoc, diag::err_selector_element_type)
+        << FirstType << First->getSourceRange();
+
+  // Make sure range start is of the right type. Resolve if overloaded.
+  if (!EnumRangeStart->getType()->isStrictEnumeralType()) {
+    if (EnumRangeStart->getType()->isSpecificBuiltinType(BuiltinType::Overload)) {
+      Expr* resolved = ResolveStrictEnumExpr(FirstType, EnumRangeStart);
+      if (resolved)
+        EnumRangeStart = resolved;
+    }
+    if (!EnumRangeStart->getType()->isStrictEnumeralType()) {
+
+      Diag(ForLoc, 
+           diag::err_typecheck_cond_incompatible_operands) << 
+           FirstType << EnumRangeStart->getType() << 
+           First->getSourceRange() << EnumRangeStart->getSourceRange();
+    }
+  }
+  llvm::APSInt rangeStartValue;
+  if (!EnumRangeStart->isIntegerConstantExpr(rangeStartValue, Context)) {
+    Diag(EnumRangeStart->getExprLoc(), 
+         diag::err_expr_not_ice) << EnumRangeStart->getSourceRange();
+  }
+  
+  // Make sure range end is of the right type. Resolve if overloaded.
+  if (!EnumRangeEnd->getType()->isStrictEnumeralType()) {
+    if (EnumRangeEnd->getType()->isSpecificBuiltinType(BuiltinType::Overload)) {
+      Expr* resolved = ResolveStrictEnumExpr(FirstType, EnumRangeEnd);
+      if (resolved)
+        EnumRangeEnd = resolved;
+    }
+    if (!EnumRangeEnd->getType()->isStrictEnumeralType()) {
+
+      Diag(ForLoc, 
+           diag::err_typecheck_cond_incompatible_operands) << 
+           FirstType << EnumRangeEnd->getType() << 
+           First->getSourceRange() << EnumRangeEnd->getSourceRange();
+    }
+  }
+  llvm::APSInt rangeEndValue;
+  if (!EnumRangeEnd->isIntegerConstantExpr(rangeEndValue, Context)) {
+    Diag(EnumRangeEnd->getExprLoc(), 
+         diag::err_expr_not_ice) << EnumRangeEnd->getSourceRange();
+  }
+
+  ExprResult assignExpr = 
+      CreateBuiltinBinOp(First->getLocStart(),
+                         BO_Assign,
+                         varExpr,
+                         EnumRangeStart);
+
+  Stmt* initStmt; 
+  if (hasDeclaration) {
+    Stmt* statements[2] = { First, assignExpr.take() };
+    initStmt = new (Context) CompoundStmt(Context,
+                                          statements,
+                                          2,
+                                          SourceLocation(),
+                                          SourceLocation());
+  } else {
+    initStmt = assignExpr.take();
+  }
+
+  // Handle forward and reverse traversal
+  BinaryOperatorKind CondOp;
+  UnaryOperatorKind IncrOp;
+  if (rangeEndValue > rangeStartValue) {
+    CondOp = BO_LE;
+    IncrOp = UO_PostInc;
+  } else {
+    CondOp = BO_GE;
+    IncrOp = UO_PostDec;
+  }
+ 
+  ExprResult condExpr = CreateBuiltinBinOp(SourceLocation(),
+                                           CondOp,
+                                           varExpr,
+                                           EnumRangeEnd );
+
+  ExprResult incrExpr = CreateBuiltinUnaryOp(SourceLocation(),
+                                             IncrOp,
+                                             varExpr );
+
+  return Owned(new (Context) ForStmt(Context, initStmt, 
+                                     condExpr.take(), 0, 
+                                     incrExpr.take(), Body, ForLoc, 
+                                     SourceLocation(), SourceLocation()));
+}
+
+/// Eero: "for <int> i in <NSRange>" loop
+StmtResult 
+Sema::ActOnForRangeStmt(SourceLocation ForLoc,
+                        Stmt *First, 
+                        Expr* Second, 
+                        Stmt *Body) {
+
+  assert(getLangOptions().Eero && First &&
+         "The parser shouldn't call this if there is no expr before 'in'.");
+
+  QualType FirstType;
+  bool hasDeclaration;
+  Expr* varExpr;
+  if (DeclStmt *DS = dyn_cast<DeclStmt>(First)) {
+    if (!DS->isSingleDecl())
+      return StmtError(Diag((*DS->decl_begin())->getLocation(),
+                       diag::err_toomany_element_decls));
+
+    hasDeclaration = true;  
+    Decl *D = DS->getSingleDecl();
+    FirstType = cast<ValueDecl>(D)->getType();
+    // C99 6.8.5p3: The declaration part of a 'for' statement shall only
+    // declare identifiers for objects having storage class 'auto' or
+    // 'register'.
+    VarDecl *VD = cast<VarDecl>(D);
+    if (VD->isLocalVarDecl() && !VD->hasLocalStorage())
+      return StmtError(Diag(VD->getLocation(),
+                            diag::err_non_variable_decl_in_for));
+
+    ValueDecl *valDecl = cast<ValueDecl>(D);
+    varExpr = new (Context) DeclRefExpr(valDecl, FirstType, VK_LValue, SourceLocation());
+  } else {
+    varExpr = cast<Expr>(First);
+    if (!varExpr->isTypeDependent() && !varExpr->isLValue()) {
+      return StmtError(Diag(First->getLocStart(),
+                 diag::err_selector_element_not_lvalue)
+        << First->getSourceRange());
+    }
+    hasDeclaration = false;
+    FirstType = static_cast<Expr*>(First)->getType();
+  }
+
+  if (!FirstType->isIntegerType() || FirstType->isStrictEnumeralType())
+      Diag(ForLoc, diag::err_selector_element_type)
+        << FirstType << First->getSourceRange();
+
+  // Begin loop at <NSRange>.location
+  UnqualifiedId Name;
+  Name.setIdentifier(&(PP.getIdentifierTable().getOwn("location")),
+                     Second->getLocStart());
+  CXXScopeSpec SS;
+  ExprResult beginExpr = 
+      ActOnMemberAccessExpr(getCurScope(), 
+                            Second, 
+                            Second->getLocStart(), 
+                            tok::period, 
+                            SS, Name, 0, false);
+
+  // End loop at <NSRange>.location + <NSRange>.length
+  Name.setIdentifier(&(PP.getIdentifierTable().getOwn("length")),
+                     Second->getLocStart());
+  ExprResult lengthExpr = 
+      ActOnMemberAccessExpr(getCurScope(),
+                            Second, 
+                            Second->getLocStart(), 
+                            tok::period, 
+                            SS, Name, 0, false);
+  ExprResult endExpr = 
+      CreateBuiltinBinOp(First->getLocStart(),
+                         BO_Add,
+                         beginExpr.get(),
+                         lengthExpr.take());
+
+  ExprResult assignExpr = 
+      CreateBuiltinBinOp(First->getLocStart(),
+                         BO_Assign,
+                         varExpr,
+                         beginExpr.take());
+
+  Stmt* initStmt; 
+  if (hasDeclaration) {
+    Stmt* statements[2] = { First, assignExpr.take() };
+    initStmt = new (Context) CompoundStmt(Context,
+                                          statements,
+                                          2,
+                                          SourceLocation(),
+                                          SourceLocation());
+  } else {
+    initStmt = assignExpr.take();
+  }
+
+  ExprResult condExpr = CreateBuiltinBinOp(SourceLocation(),
+                                           BO_LT,
+                                           varExpr,
+                                           endExpr.take() );
+
+  ExprResult incrExpr = CreateBuiltinUnaryOp(SourceLocation(),
+                                             UO_PostInc,
+                                             varExpr );
+
+  return Owned(new (Context) ForStmt(Context, initStmt, 
+                                     condExpr.take(), 0, 
+                                     incrExpr.take(), Body, ForLoc, 
+                                     SourceLocation(), SourceLocation()));
+}
+
 StmtResult
 Sema::ActOnObjCForCollectionStmt(SourceLocation ForLoc,
                                  SourceLocation LParenLoc,
Index: lib/Sema/SemaLookup.cpp
===================================================================
--- lib/Sema/SemaLookup.cpp	(revision 129311)
+++ lib/Sema/SemaLookup.cpp	(working copy)
@@ -29,6 +29,7 @@
 #include "clang/AST/ExprCXX.h"
 #include "clang/Basic/Builtins.h"
 #include "clang/Basic/LangOptions.h"
+#include "clang/Lex/Preprocessor.h"
 #include "llvm/ADT/DenseSet.h"
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/SmallPtrSet.h"
@@ -1054,11 +1055,12 @@
 /// @returns The result of name lookup, which includes zero or more
 /// declarations and possibly additional information used to diagnose
 /// ambiguities.
-bool Sema::LookupName(LookupResult &R, Scope *S, bool AllowBuiltinCreation) {
+bool Sema::LookupName(LookupResult &R, Scope *S, bool AllowBuiltinCreation, bool doPrefixLookup) {
   DeclarationName Name = R.getLookupName();
   if (!Name) return false;
 
   LookupNameKind NameKind = R.getLookupKind();
+  Scope* curScope = S;
 
   if (!getLangOptions().CPlusPlus) {
     // Unqualified name lookup in C/Objective-C is purely lexical, so
@@ -1119,6 +1121,12 @@
 
         R.resolveKind();
 
+        // Support overloaded Eero strict enum constants
+        if (getLangOptions().Eero && 
+            isa<EnumConstantDecl>(*I) &&
+            dyn_cast<EnumConstantDecl>(*I)->getType()->isStrictEnumeralType()) {
+          continue; // add to list instead of returning with just one
+        }
         return true;
       }
   } else {
@@ -1133,6 +1141,30 @@
   if (AllowBuiltinCreation)
     return LookupBuiltin(*this, R);
 
+  if (getLangOptions().Eero && doPrefixLookup) { // use Eero prefix typedefs
+
+    const std::string& name(Name.getAsString());
+    Scope* prefixScope = curScope;
+    bool found = false;
+
+    // First check for the almighty "NS" prefix
+    R.setLookupName(&(PP.getIdentifierTable().getOwn("NS" + name)));
+    found = LookupName(R, curScope);
+    
+    while (!found && prefixScope) { // now check for any explicit prefix typedefs
+      for ( Scope::prefix_iterator it = prefixScope->prefix_begin(); 
+            !found && it < prefixScope->prefix_end(); 
+            it++ ) {
+        R.setLookupName(&(PP.getIdentifierTable().getOwn(*it + name)));
+        found = LookupName(R, curScope);
+      }
+      prefixScope = prefixScope->getParent(); // keep looking in enclosing scopes
+    }
+
+    if (!found) R.setLookupName(Name); // restore orig name for diagnostics
+    return found;
+  }
+
   // If we didn't find a use of this identifier, the ExternalSource 
   // may be able to handle the situation. 
   // Note: some lookup failures are expected!
@@ -2081,7 +2113,7 @@
                                   LookupNameKind NameKind,
                                   RedeclarationKind Redecl) {
   LookupResult R(*this, Name, Loc, NameKind, Redecl);
-  LookupName(R, S);
+  LookupName(R, S,false,true);
   return R.getAsSingle<NamedDecl>();
 }
 
Index: lib/Sema/SemaExprObjC.cpp
===================================================================
--- lib/Sema/SemaExprObjC.cpp	(revision 129311)
+++ lib/Sema/SemaExprObjC.cpp	(working copy)
@@ -443,6 +443,12 @@
   // If that failed, look for an "implicit" property by seeing if the nullary
   // selector is implemented.
 
+  if (getLangOptions().Eero) { // Eero only allows dot notation on explicit properties
+    Diag(MemberLoc, diag::err_property_not_found)
+      << MemberName << QualType(OPT, 0);
+    return ExprError();
+  }
+
   // FIXME: The logic for looking up nullary and unary selectors should be
   // shared with the code in ActOnInstanceMessage.
 
@@ -584,6 +590,11 @@
     }
   }
 
+  if (getLangOptions().Eero) { // Eero only allows dot notation on explicit properties
+    return ExprError(Diag(propertyNameLoc, diag::err_property_not_found)
+                       << &propertyName << Context.getObjCInterfaceType(IFace));
+  }
+
   // Search for a declared property first.
   Selector Sel = PP.getSelectorTable().getNullarySelector(&propertyName);
   ObjCMethodDecl *Getter = IFace->lookupClassMethod(Sel);
@@ -665,7 +676,7 @@
     return HasTrailingDot? ObjCInstanceMessage : ObjCSuperMessage;
   
   LookupResult Result(*this, Name, NameLoc, LookupOrdinaryName);
-  LookupName(Result, S);
+  LookupName(Result, S,false,true);
   
   switch (Result.getResultKind()) {
   case LookupResult::NotFound:
@@ -841,7 +852,7 @@
                                    MultiExprArg ArgsIn) {
   SourceLocation Loc = SuperLoc.isValid()? SuperLoc
     : ReceiverTypeInfo->getTypeLoc().getSourceRange().getBegin();
-  if (LBracLoc.isInvalid()) {
+  if (!getLangOptions().Eero && LBracLoc.isInvalid()) {
     Diag(Loc, diag::err_missing_open_square_message_send)
       << FixItHint::CreateInsertion(Loc, "[");
     LBracLoc = Loc;
@@ -897,6 +908,19 @@
 
   unsigned NumArgs = ArgsIn.size();
   Expr **Args = reinterpret_cast<Expr **>(ArgsIn.release());
+
+  ExprVector argExprs(*this);
+  if (getLangOptions().Eero &&          // Eero adds nil/null to
+      Method && Method->isVariadic()) { // end of all variadic calls
+    for (unsigned int i=0; i < NumArgs; i++) {
+      argExprs.push_back(Args[i]);
+    }
+    ExprResult nilArg = ActOnGNUNullExpr(RBracLoc);
+    argExprs.push_back(nilArg.release());
+    Args = argExprs.take();
+    NumArgs++;
+  }
+
   if (CheckMessageArgumentTypes(Args, NumArgs, Sel, Method, true,
                                 LBracLoc, RBracLoc, ReturnType, VK))
     return ExprError();
@@ -984,7 +1008,7 @@
   // The location of the receiver.
   SourceLocation Loc = SuperLoc.isValid()? SuperLoc : Receiver->getLocStart();
   
-  if (LBracLoc.isInvalid()) {
+  if (!getLangOptions().Eero && LBracLoc.isInvalid()) {
     Diag(Loc, diag::err_missing_open_square_message_send)
       << FixItHint::CreateInsertion(Loc, "[");
     LBracLoc = Loc;
@@ -1163,6 +1187,19 @@
   // Check the message arguments.
   unsigned NumArgs = ArgsIn.size();
   Expr **Args = reinterpret_cast<Expr **>(ArgsIn.release());
+
+  ExprVector argExprs(*this);
+  if (getLangOptions().Eero &&          // Eero adds nil/null to
+      Method && Method->isVariadic()) { // end of all variadic calls
+    for (unsigned int i=0; i < NumArgs; i++) {
+      argExprs.push_back(Args[i]);
+    }
+    ExprResult nilArg = ActOnGNUNullExpr(RBracLoc);
+    argExprs.push_back(nilArg.release());
+    Args = argExprs.take();
+    NumArgs++;
+  }
+
   QualType ReturnType;
   ExprValueKind VK = VK_RValue;
   bool ClassMessage = (ReceiverType->isObjCClassType() ||
Index: lib/Sema/SemaExpr.cpp
===================================================================
--- lib/Sema/SemaExpr.cpp	(revision 129311)
+++ lib/Sema/SemaExpr.cpp	(working copy)
@@ -1636,8 +1636,18 @@
     }
   }
 
-  if (R.isAmbiguous())
-    return ExprError();
+  if (R.isAmbiguous()) {
+    bool allow = false;
+    if (getLangOptions().Eero) {
+      NamedDecl* decl = R.getRepresentativeDecl();
+      if (isa<EnumConstantDecl>(decl) &&
+          cast<EnumConstantDecl>(decl)->getType()->isStrictEnumeralType()) {
+        allow = true;
+      }
+    }
+    if (!allow)
+      return ExprError();
+  }
 
   // Determine whether this name might be a candidate for
   // argument-dependent lookup.
@@ -2897,6 +2907,15 @@
   case tok::minusminus: Opc = UO_PostDec; break;
   }
 
+  // Eero strict enums disallow all postfix unary operators
+  if (getLangOptions().Eero && 
+      Input->getType()->isStrictEnumeralType() &&
+      Input->isLValue()) {
+    return ExprError(Diag(OpLoc, diag::err_ovl_no_oper) <<
+                     Input->getType() << UnaryOperator::getOpcodeStr(Opc) <<
+                     Input->getSourceRange());
+  }
+
   return BuildUnaryOp(S, OpLoc, Opc, Input);
 }
 
@@ -2916,6 +2935,15 @@
 ExprResult
 Sema::ActOnArraySubscriptExpr(Scope *S, Expr *Base, SourceLocation LLoc,
                               Expr *Idx, SourceLocation RLoc) {
+  if (getLangOptions().Eero) {
+    ExprResult ObjectResult =
+      ActOnObjectSubscriptExpr(S, Base, LLoc, Idx, RLoc);
+
+    // If an error or not an empty expression, return now
+    if (ObjectResult.isInvalid() || ObjectResult.isUsable())
+      return ObjectResult;
+  }
+
   // Since this might be a postfix expression, get rid of ParenListExprs.
   ExprResult Result = MaybeConvertParenListExprToParenExpr(S, Base);
   if (Result.isInvalid()) return ExprError();
@@ -3075,6 +3103,123 @@
                                                 ResultType, VK, OK, RLoc));
 }
 
+/// Eero: support object "[]" operators
+ExprResult
+Sema::ActOnObjectSubscriptExpr(Scope *S, Expr *Base, SourceLocation LLoc,
+                               Expr *Idx, SourceLocation RLoc) {
+
+  // Not really an object operation, but reject strict enum indexes
+  if (Idx->getType()->isStrictEnumeralType()) {
+    return ExprError(Diag(LLoc, diag::err_typecheck_subscript_not_integer)
+                     << Idx->getSourceRange());
+  }
+  // Support object "[]" operator for integer and NSRange subscripts (array
+  // objects), and for object subscripts (KVC and dictionaries).
+  // If anything else, just pass through (return empty expr).
+  if (Base->getType()->isObjCObjectPointerType()) {
+    std::string SelName;
+    if (Idx->getType()->isIntegerType()) {
+      SelName = "objectAtIndex";
+    } else if (Idx->getType()->isObjCObjectPointerType()) {
+      SelName = "valueForKey";
+    } else { // check for NSRange index
+      // Make sure type NSRange is defined. If not, don't recognize
+      // NSRange subscripts.
+      ParsedType RangeType = 
+          getTypeName(PP.getIdentifierTable().getOwn("NSRange"), 
+                      LLoc, 
+                      getCurScope());
+      if (!RangeType.get().isNull() && Idx->getType() == RangeType.get())
+          SelName = "subarrayWithRange";
+    }
+    if (!SelName.empty()) {
+      IdentifierInfo &II = PP.getIdentifierTable().getOwn(SelName);      
+      Selector Sel = PP.getSelectorTable().getUnarySelector(&II);
+      if (!Sel.isNull()) {
+        return ActOnInstanceMessage(S,
+                                    Base, 
+                                    Sel,
+                                    LLoc,
+                                    RLoc,
+                                    RLoc,
+                                    MultiExprArg(*this,&Idx,1));
+      } else {
+        // Something strange went wrong if we got here
+        return ExprError();
+      }
+    }
+  }
+  return ExprEmpty();
+}
+
+/// Eero: support object "[]=" operator for integer or NSRange 
+/// subscripts (arrays) and for object subscripts (KVC and dictionaries).
+ExprResult
+Sema::ActOnObjectSubscriptAssignment(Scope *S,
+                                   Expr *Base, SourceLocation BLoc,
+                                   Expr *Idx, SourceLocation ILoc,
+                                   Expr *RHS, SourceLocation ELoc) {
+  ExprResult result = ExprError();
+  Selector Sel;
+  Expr* args[2] = {0, 0};
+
+  if (Idx->getType()->isIntegerType() &&          // array-like object
+      !Idx->getType()->isStrictEnumeralType()) {
+
+    IdentifierInfo* selParts[] = 
+        { &PP.getIdentifierTable().getOwn("replaceObjectAtIndex"), 
+          &PP.getIdentifierTable().getOwn("withObject") };    
+
+    Sel = PP.getSelectorTable().getSelector(2, selParts);
+    args[0] = Idx;
+    args[1] = RHS;
+
+  } else if (Idx->getType()->isObjCObjectPointerType()) { // KVC (or Dictionary)
+
+    IdentifierInfo* selParts[] = 
+        { &PP.getIdentifierTable().getOwn("setValue"), 
+          &PP.getIdentifierTable().getOwn("forKey") };
+
+    Sel = PP.getSelectorTable().getSelector(2, selParts);
+    args[0] = RHS;
+    args[1] = Idx;
+
+  } else { // check for NSRange subscript (array-like object)
+
+    // Make sure type NSRange is defined. If not, don't recognize
+    // NSRange subscripts.
+    ParsedType RangeType = 
+        getTypeName(PP.getIdentifierTable().getOwn("NSRange"), 
+                    ILoc, 
+                    getCurScope());
+    if (!RangeType.get().isNull() && Idx->getType() == RangeType.get()) {
+      IdentifierInfo* selParts[] = 
+          { &PP.getIdentifierTable().getOwn("replaceObjectsInRange"), 
+            &PP.getIdentifierTable().getOwn("withObjectsFromArray") };    
+
+      Sel = PP.getSelectorTable().getSelector(2, selParts);
+      args[0] = Idx;
+      args[1] = RHS;
+    }
+  }
+
+  if (args[0] == 0) { // unknown subscript type
+    result = ExprError(Diag(BLoc, diag::err_typecheck_subscript_not_integer)
+                       << Idx->getSourceRange());
+  }
+
+  if (!Sel.isNull()) {
+    result = ActOnInstanceMessage(S,
+                                  Base, 
+                                  Sel,
+                                  BLoc,
+                                  ILoc,
+                                  ELoc,
+                                  MultiExprArg(*this,args,2));
+  }
+  return result;
+}
+
 /// Check an ext-vector component access expression.
 ///
 /// VK should be set in advance to the value kind of the base
@@ -5136,7 +5281,67 @@
   if (isa<ParenListExpr>(castExpr))
     return ActOnCastOfParenListExpr(S, LParenLoc, RParenLoc, castExpr,
                                     castTInfo);
+  // Support Eero Class and object casts
+  if (getLangOptions().Eero) { 
+    const QualType castExprType = castExpr->getType();
+    ExprResult result = ExprEmpty();
 
+    if (castType->isObjCObjectType()) {  // treat "(String)x" as "(String*)x"
+      castType = Context.getObjCObjectPointerType(castType);
+      castTInfo = Context.getTrivialTypeSourceInfo(castType);
+    } else if (castType->isObjCObjectPointerType() &&  // get underlying class for
+               !castType->isObjCIdType()) {            // possible message sends
+      Ty = ParsedType::make(castType->getPointeeType());
+    }
+    if (castType->isObjCObjectPointerType()) {            // convert to a class from...
+      if (castExprType->isObjCObjectPointerType() ||             // another object type
+          castExprType->isVoidPointerType() ||                   // a void pointer
+          (castExprType->isPointerType() &&                      // a struct pointer
+           castExprType->getPointeeType()->isStructureType())) { // (for CF types)
+        // these are simply normal casts, so just pass along
+      } else if (castType->isObjCIdType()) { // stop here if cast type is 'id'
+        if (!castExprType->isBlockPointerType()) {
+          result = ExprError();
+        }
+      } else if (castExprType->isArithmeticType() &&    // a builtin numeric
+                 castExprType->isBuiltinType()) {       // type
+        result = ActOnArithmeticTypeToObjectCast(S, LParenLoc, Ty, RParenLoc, castExpr);
+
+      } else if (castExprType->isPointerType() &&       // a C string (char*)
+                 castExprType->getPointeeType()->isCharType()) {
+        result = ActOnCStringTypeToObjectCast(S, LParenLoc, Ty, RParenLoc, castExpr);
+
+      } else if (castExprType->isConstantArrayType() && // a C string literal
+                 Context.getAsConstantArrayType(castExprType)->
+                      getElementType()->isCharType()) {
+          result = ActOnCStringTypeToObjectCast(S, LParenLoc, Ty, RParenLoc, castExpr);
+      } else { // unsupported conversion
+        result = ExprError();
+      }
+    } else if (castExprType->isObjCObjectPointerType()) { // convert an object to...
+      if (castType->isArithmeticType() &&                   // a primitive arithmetic
+          castType->isBuiltinType()) {                      // data type
+        result = ActOnObjectToArithmeticTypeCast(S, LParenLoc, castType, RParenLoc, castExpr);
+      } else if (castType->isPointerType() &&                // a C string (char*)
+                 castType->getPointeeType()->isCharType()) { //
+        result = ActOnObjectToCStringTypeCast(S, LParenLoc, castType, RParenLoc, castExpr);
+      } else if (!(castType->isVoidPointerType() ||                  // a void pointer
+                  (castType->isPointerType() &&                      // a struct pointer
+                   castType->getPointeeType()->isStructureType()) || // (for CF types)
+                  (castType->isBlockPointerType() &&                 // a block (only if
+                   castExprType->isObjCIdType()))) {                 // an id)
+        result = ExprError();
+      }
+    }
+    if (result.isInvalid()) {
+      Diag(LParenLoc, diag::err_unsupported_class_or_object_cast)
+          << castExpr->getSourceRange()
+          << castExprType << castType;
+      return result;
+    }
+    if (result.isUsable())
+      return result;
+  }
   return BuildCStyleCastExpr(LParenLoc, castTInfo, RParenLoc, castExpr);
 }
 
@@ -6246,6 +6451,33 @@
     return Compatible;
   }
 
+  // For Eero strict enums, allow assignments only if both sides are the same type.
+  // If the expression on the right is overloaded, resolve it with the left's type.
+  if (getLangOptions().Eero && lhsType->isStrictEnumeralType()) {
+    Sema::AssignConvertType result = Incompatible;
+    QualType rhsType = rExpr->getType();
+    if (rhsType->isStrictEnumeralType()) {
+      if (lhsType->getCanonicalTypeUnqualified() == 
+          rhsType->getCanonicalTypeUnqualified()) {
+        result = Compatible;
+      } else {
+        Diag(rExpr->getLocStart(), diag::err_typecheck_cond_incompatible_operands)
+          << lhsType << rhsType << rExpr->getSourceRange();        
+      }
+    } else if (rhsType->isSpecificBuiltinType(BuiltinType::Overload)) {
+      Expr* rhsExpr = ResolveStrictEnumExpr(lhsType, rExpr);
+      if (rhsExpr) {
+        // delete rExpr; // TODO: free up old expression?
+        rExpr = rhsExpr;
+        result = Compatible;
+      }
+    } else {
+      Diag(rExpr->getLocStart(), diag::err_typecheck_cond_incompatible_operands)
+        << lhsType << rhsType << rExpr->getSourceRange();        
+    }
+    return result;
+  }
+
   // This check seems unnatural, however it is necessary to ensure the proper
   // conversion of functions/arrays. If the conversion were done for all
   // DeclExpr's (created by ActOnIdExpression), it would mess up the unary
@@ -7970,6 +8202,29 @@
       << lhs->getSourceRange() << rhs->getSourceRange();
 }
 
+// Eero
+static inline std::string ConvertTokenKindToBinarySelectorName(
+  tok::TokenKind Kind, bool& invert) {
+  std::string SelectorName;
+  invert = false;
+  switch (Kind) {
+    case tok::equalequal:     SelectorName = "isEqual"; break;
+    case tok::exclaimequal:   SelectorName = "isEqual"; invert = true; break;
+    case tok::plus:           SelectorName = "plus"; break;
+    case tok::minus:          SelectorName = "minus"; break;
+    case tok::star:           SelectorName = "multipliedBy"; break;
+    case tok::slash:          SelectorName = "dividedBy"; break;
+    case tok::less:           SelectorName = "isLess"; break;
+    case tok::lessequal:      SelectorName = "isGreater"; invert = true; break;      
+    case tok::greater:        SelectorName = "isGreater"; break;
+    case tok::greaterequal:   SelectorName = "isLess"; invert = true; break;
+    case tok::lessless:       SelectorName = "shiftLeft"; break;
+    case tok::greatergreater: SelectorName = "shiftRight"; break;
+    default:; // do nothing, leaving SelectorName empty
+  }
+  return SelectorName;
+}
+
 /// CreateBuiltinBinOp - Creates a new built-in binary operation with
 /// operator @p Opc at location @c TokLoc. This routine only supports
 /// built-in operations; ActOnBinOp handles overloaded operators.
@@ -8276,6 +8531,13 @@
   assert((lhs != 0) && "ActOnBinOp(): missing left expression");
   assert((rhs != 0) && "ActOnBinOp(): missing right expression");
 
+  if (getLangOptions().Eero) {  
+    ExprResult result = ActOnEeroBinOp(S, TokLoc, Kind, Opc, lhs, rhs);    
+    if (result.isUsable() || result.isInvalid()) {
+      return result;
+    }
+  }
+
   // Emit warnings for tricky precedence issues, e.g. "bitfield & 0x4 == 0"
   DiagnoseBinOpPrecedence(*this, Opc, TokLoc, lhs, rhs);
 
@@ -8454,6 +8716,18 @@
 // Unary Operators.  'Tok' is the token for the operator.
 ExprResult Sema::ActOnUnaryOp(Scope *S, SourceLocation OpLoc,
                               tok::TokenKind Op, Expr *Input) {
+  // The only unary operator allowed on an Eero strict enum is getting its
+  // address (&).
+  if (getLangOptions().Eero && 
+      Op != tok::amp && 
+      Input->getType()->isStrictEnumeralType() &&
+      Input->isLValue()) {
+    return ExprError(Diag(OpLoc, diag::err_ovl_no_oper) <<
+                     Input->getType() << 
+                     UnaryOperator::getOpcodeStr(ConvertTokenKindToUnaryOpcode(Op)) <<
+                     Input->getSourceRange());
+  }
+
   return BuildUnaryOp(S, OpLoc, ConvertTokenKindToUnaryOpcode(Op), Input);
 }
 
@@ -9728,3 +10002,312 @@
   Diag(Loc, diag::err_ovl_unresolvable) << E->getSourceRange();
   return ExprError();
 }
+
+// Eero supports limited operator overloading for ObjC objects. It also limits
+// the operators allowed for its strict enums; only assignments and comparisons
+// are allowed. It also supports overloading of strict enum member constants.
+ExprResult Sema::ActOnEeroBinOp(Scope *S, SourceLocation TokLoc,
+                                tok::TokenKind Kind, BinaryOperatorKind Opc,
+                                Expr *lhs, Expr *rhs) {
+  ExprResult result;  
+
+  // If both operands are object instances, perform operator overloading
+  if (lhs->getType()->isObjCObjectPointerType() && 
+      rhs->getType()->isObjCObjectPointerType()) { 
+
+    bool invert;
+    std::string SelName = ConvertTokenKindToBinarySelectorName(Kind, invert);
+    if (!SelName.empty()) {
+      IdentifierInfo &II = PP.getIdentifierTable().getOwn(SelName);      
+      Selector Sel = PP.getSelectorTable().getUnarySelector(&II);
+      if (!Sel.isNull()) {
+        result = ActOnInstanceMessage(S,
+                                      lhs, 
+                                      Sel,
+                                      TokLoc,
+                                      TokLoc,
+                                      TokLoc,
+                                      MultiExprArg(*this,&rhs,1));
+        if (invert) {
+          result = ActOnUnaryOp(S, TokLoc, tok::exclaim, result.take());
+        }
+      }
+    }
+  } else if (lhs->getType()->isSpecificBuiltinType(BuiltinType::Overload) &&
+             rhs->getType()->isSpecificBuiltinType(BuiltinType::Overload)) {
+
+    Diag(TokLoc, diag::err_ovl_ambiguous_oper_binary) << 
+        BinaryOperator::getOpcodeStr(Opc) << lhs->getSourceRange() << 
+        rhs->getSourceRange();
+    result = ExprError();
+
+  } else if (lhs->getType()->isStrictEnumeralType() ||
+             rhs->getType()->isStrictEnumeralType()) {        
+
+    if (rhs->getType()->isSpecificBuiltinType(BuiltinType::Overload)) {
+      Expr* rhsExpr = ResolveStrictEnumExpr(lhs->getType(), rhs);
+      if (rhsExpr)
+        result = ActOnBinOp(S, TokLoc, Kind, lhs, rhsExpr);
+    } else if (lhs->getType()->isSpecificBuiltinType(BuiltinType::Overload)) {
+      Expr* lhsExpr = ResolveStrictEnumExpr(rhs->getType(), lhs);
+      if (lhsExpr)
+        result = ActOnBinOp(S, TokLoc, Kind, lhsExpr, rhs);
+    } else {
+      switch (Kind) {
+        case tok::lessequal:
+        case tok::less:
+        case tok::greaterequal:
+        case tok::greater:
+        case tok::exclaimequal:
+        case tok::equalequal:
+        case tok::equal:
+          if (lhs->getType()->getCanonicalTypeUnqualified() != 
+              rhs->getType()->getCanonicalTypeUnqualified()) {
+            Diag(TokLoc, diag::err_typecheck_cond_incompatible_operands) << 
+                 lhs->getType() << rhs->getType() << 
+                 lhs->getSourceRange() << rhs->getSourceRange();
+            result = ExprError();
+          }
+          break;
+        default:
+          if (lhs->getType()->isStrictEnumeralType()) {
+            Diag(TokLoc, diag::err_ovl_no_oper) << 
+                 lhs->getType() << BinaryOperator::getOpcodeStr(Opc) << 
+                 lhs->getSourceRange();            
+          } else {
+            Diag(TokLoc, diag::err_ovl_no_oper) << 
+                 rhs->getType() << BinaryOperator::getOpcodeStr(Opc) << 
+                 rhs->getSourceRange();
+          }
+          result = ExprError();
+      }
+    }
+  }
+  return result;
+}
+
+// For Eero strict enum support of overloaded member constants
+Expr* Sema::ResolveStrictEnumExpr(QualType KnownType, Expr* OverloadedExpr) {
+
+  Expr* resolvedExpr = 0;
+  UnresolvedLookupExpr *ULE = cast<UnresolvedLookupExpr>(OverloadedExpr);
+  for ( UnresolvedSetImpl::iterator it = ULE->decls_begin(); it != ULE->decls_end(); it++ ) {
+    if (isa<EnumConstantDecl>(*it)) {
+      EnumConstantDecl* enumConstDecl = cast<EnumConstantDecl>(*it);
+      QualType resolvedType = enumConstDecl->getType();
+      if (resolvedType == KnownType->getCanonicalTypeUnqualified()) {
+        resolvedExpr = new (Context) DeclRefExpr(enumConstDecl, 
+                                                 resolvedType, 
+                                                 VK_RValue,
+                                                 OverloadedExpr->getLocStart());
+        break;
+      }
+    }
+  }
+  return resolvedExpr;
+}
+
+// Eero: "cast" a built-in numeric value (e.g. int or float) to an object type,
+// using class method selectors "numberWith<Type>".
+ExprResult Sema::ActOnArithmeticTypeToObjectCast(Scope *S,
+                                                 SourceLocation LParenLoc,
+                                                 ParsedType ClassType, 
+                                                 SourceLocation RParenLoc,
+                                                 Expr* CastExpr) {
+
+  const BuiltinType *BT = CastExpr->getType()->getAs<BuiltinType>();
+  std::string suffix;
+  ExprResult result;
+  
+  switch (BT->getKind()) {
+    case BuiltinType::Bool:
+      suffix = "Bool";
+      break;
+    case BuiltinType::Char_U:
+    case BuiltinType::UChar:
+      suffix = "UnsignedChar";
+      break;
+    case BuiltinType::UShort:
+      suffix = "UnsignedShort";
+      break;
+    case BuiltinType::UInt:
+      suffix = "UnsignedInt";
+      break;
+    case BuiltinType::ULong:
+      suffix = "UnsignedLong";
+      break;
+    case BuiltinType::ULongLong:
+      suffix = "UnsignedLongLong";
+      break;
+    case BuiltinType::Char_S:
+    case BuiltinType::SChar:
+      suffix = "Char";
+      break;
+    case BuiltinType::Short:
+      suffix = "Short";
+      break;
+    case BuiltinType::Int:
+      suffix = "Int";
+      break;
+    case BuiltinType::Long:
+      suffix = "Long";
+      break;
+    case BuiltinType::LongLong:
+      suffix = "LongLong";
+      break;
+    case BuiltinType::Float:
+      suffix = "Float";
+      break;
+    case BuiltinType::Double:
+      suffix = "Double";
+      break;
+    case BuiltinType::LongDouble:
+      suffix = "LongDouble"; // Note: does not exist for NSNumber, but other classes may support it
+      break;
+    default:
+      Diag(LParenLoc, diag::err_unsupported_class_or_object_cast)
+          << CastExpr->getSourceRange()
+          << CastExpr->getType() << GetTypeFromParser(ClassType);        
+      result = ExprError();
+      break;
+  }
+
+  if (!suffix.empty()) {
+    IdentifierInfo &II = PP.getIdentifierTable().getOwn("numberWith" + suffix);      
+    Selector Sel = PP.getSelectorTable().getUnarySelector(&II);
+
+    result = ActOnClassMessage(S,
+                               ClassType,
+                               Sel,
+                               LParenLoc, RParenLoc, CastExpr->getLocEnd(),
+                               MultiExprArg(*this,&CastExpr,1));
+  }
+  
+  return result;
+}
+
+// Eero: "cast" an object to a built in numeric value (e.g. int or float)
+// using instance method selectors "<type>Value".
+ExprResult Sema::ActOnObjectToArithmeticTypeCast(Scope *S,
+                                                 SourceLocation LParenLoc,
+                                                 QualType ArithmeticType, 
+                                                 SourceLocation RParenLoc,
+                                                 Expr* CastExpr) {
+
+  const BuiltinType *BT = ArithmeticType->getAs<BuiltinType>();
+  std::string prefix;
+  ExprResult result;
+  
+  switch (BT->getKind()) {
+    case BuiltinType::Bool:
+      prefix = "bool";
+      break;
+    case BuiltinType::Char_U:
+    case BuiltinType::UChar:
+      prefix = "unsignedChar";
+      break;
+    case BuiltinType::UShort:
+      prefix = "unsignedShort";
+      break;
+    case BuiltinType::UInt:
+      prefix = "unsignedInt";
+      break;
+    case BuiltinType::ULong:
+      prefix = "unsignedLong";
+      break;
+    case BuiltinType::ULongLong:
+      prefix = "unsignedLongLong";
+      break;
+    case BuiltinType::Char_S:
+    case BuiltinType::SChar:
+      prefix = "char";
+      break;
+    case BuiltinType::Short:
+      prefix = "short";
+      break;
+    case BuiltinType::Int:
+      prefix = "int";
+      break;
+    case BuiltinType::Long:
+      prefix = "long";
+      break;
+    case BuiltinType::LongLong:
+      prefix = "longLong";
+      break;
+    case BuiltinType::Float:
+      prefix = "float";
+      break;
+    case BuiltinType::Double:
+      prefix = "double";
+      break;
+    case BuiltinType::LongDouble:
+      prefix = "longDouble"; // Note: does not exist for NSNumber, but other classes may support it
+      break;
+    default:
+      Diag(LParenLoc, diag::err_unsupported_class_or_object_cast)
+          << CastExpr->getSourceRange()
+          << CastExpr->getType() << ArithmeticType;        
+      result = ExprError();
+      break;
+  }
+
+  if (!prefix.empty()) {
+    IdentifierInfo &II = PP.getIdentifierTable().getOwn( prefix + "Value");      
+    Selector Sel = PP.getSelectorTable().getNullarySelector(&II);
+
+    result = ActOnInstanceMessage(S,
+                                  CastExpr, 
+                                  Sel,
+                                  LParenLoc,
+                                  RParenLoc,
+                                  CastExpr->getLocEnd(),
+                                  MultiExprArg());
+  }
+  
+  return result;
+}
+
+// Eero: "cast" a C-style string (char*) to an object type,
+// using class method selector "stringWithUTF8String".
+ExprResult Sema::ActOnCStringTypeToObjectCast(Scope *S,
+                                              SourceLocation LParenLoc,
+                                              ParsedType ClassType, 
+                                              SourceLocation RParenLoc,
+                                              Expr* CastExpr) {
+
+  IdentifierInfo &II = PP.getIdentifierTable().getOwn("stringWithUTF8String");      
+  Selector Sel = PP.getSelectorTable().getUnarySelector(&II);
+
+  return ActOnClassMessage(S,
+                           ClassType,
+                           Sel,
+                           LParenLoc, RParenLoc, CastExpr->getLocEnd(),
+                           MultiExprArg(*this,&CastExpr,1));
+}
+
+// Eero: "cast" an object to a C-style string (const char*)
+// using instance method selector "UTF8String".
+ExprResult Sema::ActOnObjectToCStringTypeCast(Scope *S,
+                                              SourceLocation LParenLoc,
+                                              QualType CStringType, 
+                                              SourceLocation RParenLoc,
+                                              Expr* CastExpr) {
+
+  if (!CStringType->getPointeeType().isConstQualified()) {
+    Diag(LParenLoc, diag::ext_typecheck_convert_discards_qualifiers) 
+      << CastExpr->getType() << CStringType << AA_Converting
+      << CastExpr->getSourceRange();
+  }
+
+  IdentifierInfo &II = PP.getIdentifierTable().getOwn("UTF8String");      
+  Selector Sel = PP.getSelectorTable().getNullarySelector(&II);
+
+  return ActOnInstanceMessage(S,
+                              CastExpr, 
+                              Sel,
+                              LParenLoc,
+                              RParenLoc,
+                              CastExpr->getLocEnd(),
+                              MultiExprArg());
+}
+
Index: lib/AST/Type.cpp
===================================================================
--- lib/AST/Type.cpp	(revision 129311)
+++ lib/AST/Type.cpp	(working copy)
@@ -564,6 +564,12 @@
   return false;
 }
 
+bool Type::isStrictEnumeralType() const { // Eero-specific
+  if (const EnumType *ET = dyn_cast<EnumType>(CanonicalType)) {
+    return ET->getDecl()->isStrict();
+  }
+  return false;
+}
 
 bool Type::isBooleanType() const {
   if (const BuiltinType *BT = dyn_cast<BuiltinType>(CanonicalType))
Index: lib/Lex/Lexer.cpp
===================================================================
--- lib/Lex/Lexer.cpp	(revision 129311)
+++ lib/Lex/Lexer.cpp	(working copy)
@@ -2154,6 +2154,9 @@
       Kind = tok::ellipsis;
       CurPtr = ConsumeChar(ConsumeChar(CurPtr, SizeTmp, Result),
                            SizeTmp2, Result);
+    } else if (Features.Eero && Char == '.') { // Eero accepts ".." too
+      Kind = tok::ellipsis;
+      CurPtr = ConsumeChar(CurPtr, SizeTmp, Result);
     } else {
       Kind = tok::period;
     }
Index: lib/Lex/LiteralSupport.cpp
===================================================================
--- lib/Lex/LiteralSupport.cpp	(revision 129311)
+++ lib/Lex/LiteralSupport.cpp	(working copy)
@@ -341,6 +341,7 @@
 NumericLiteralParser(const char *begin, const char *end,
                      SourceLocation TokLoc, Preprocessor &pp)
   : PP(pp), ThisTokBegin(begin), ThisTokEnd(end) {
+  const LangOptions& Features = PP.getLangOptions();
 
   // This routine assumes that the range begin/end matches the regex for integer
   // and FP constants (specifically, the 'pp-number' regex), and assumes that
@@ -367,6 +368,11 @@
   } else { // the first digit is non-zero
     radix = 10;
     s = SkipDigits(s);
+    if (Features.Eero) {                      // Eero accepts and ignores
+      while (s < ThisTokEnd-1 && *s == '_') { // uderscores in the middle
+        s = SkipDigits(++s);
+      }
+    }
     if (s == ThisTokEnd) {
       // Done.
     } else if (isxdigit(*s) && !(*s == 'e' || *s == 'E')) {
@@ -378,6 +384,11 @@
       s++;
       saw_period = true;
       s = SkipDigits(s);
+      if (Features.Eero) {                      // Eero accepts and ignores
+        while (s < ThisTokEnd-1 && *s == '_') { // uderscores in the middle
+          s = SkipDigits(++s);
+        }
+      }
     }
     if ((*s == 'e' || *s == 'E')) { // exponent
       const char *Exponent = s;
@@ -512,12 +523,19 @@
 void NumericLiteralParser::ParseNumberStartingWithZero(SourceLocation TokLoc) {
   assert(s[0] == '0' && "Invalid method call");
   s++;
+  const LangOptions& Features = PP.getLangOptions();
 
   // Handle a hex number like 0x1234.
-  if ((*s == 'x' || *s == 'X') && (isxdigit(s[1]) || s[1] == '.')) {
+  if ((*s == 'x' || *s == 'X') && (isxdigit(s[1]) || s[1] == '.' || 
+                                   (Features.Eero && s[1] == '_'))) {
     s++;
     radix = 16;
     DigitsBegin = s;
+    if (Features.Eero) {                      // Eero accepts and ignores
+      while (s < ThisTokEnd-1 && *s == '_') { // uderscores in the middle
+        s = SkipHexDigits(++s);
+      }
+    }
     s = SkipHexDigits(s);
     if (s == ThisTokEnd) {
       // Done.
@@ -525,6 +543,11 @@
       s++;
       saw_period = true;
       s = SkipHexDigits(s);
+      if (Features.Eero) {                      // Eero accepts and ignores
+        while (s < ThisTokEnd-1 && *s == '_') { // uderscores in the middle
+          s = SkipHexDigits(++s);
+        }
+      }
     }
     // A binary exponent can appear with or with a '.'. If dotted, the
     // binary exponent is required.
@@ -582,6 +605,11 @@
   radix = 8;
   DigitsBegin = s;
   s = SkipOctalDigits(s);
+  if (Features.Eero) {                      // Eero accepts and ignores
+    while (s < ThisTokEnd-1 && *s == '_') { // uderscores in the middle
+      s = SkipOctalDigits(++s);
+    }
+  }
   if (s == ThisTokEnd)
     return; // Done, simple octal number like 01234
 
@@ -642,9 +670,11 @@
   unsigned MaxBitsPerDigit = 1;
   while ((1U << MaxBitsPerDigit) < radix)
     MaxBitsPerDigit += 1;
+  const LangOptions& Features(PP.getLangOptions());
   if ((SuffixBegin - DigitsBegin) * MaxBitsPerDigit <= 64) {
     uint64_t N = 0;
     for (s = DigitsBegin; s != SuffixBegin; ++s)
+      if (!Features.Eero || *s != '_') // Eero accepts and skips '_'
       N = N*radix + HexDigitValue(*s);
 
     // This will truncate the value to Val's input width. Simply check
@@ -662,6 +692,10 @@
 
   bool OverflowOccurred = false;
   while (s < SuffixBegin) {
+    if (Features.Eero && *s == '_') { // Eero accepts and skips '_'
+      s++;
+      continue;
+    }
     unsigned C = HexDigitValue(*s++);
 
     // If this letter is out of bound for this radix, reject it.
@@ -691,7 +725,24 @@
   using llvm::StringRef;
 
   unsigned n = std::min(SuffixBegin - ThisTokBegin, ThisTokEnd - ThisTokBegin);
-  return Result.convertFromString(StringRef(ThisTokBegin, n),
+
+  StringRef floatStringRef(ThisTokBegin, n);
+  std::string strippedString; // only used for Eero
+
+  if (PP.getLangOptions().Eero) { // Eero accepts underscores, so strip them out
+    size_t position = floatStringRef.find('_');
+    if (position != std::string::npos) {
+      strippedString = floatStringRef.str();
+      do {
+        strippedString.erase(position,1);
+      } while ((position = strippedString.find('_', position)) != std::string::npos);
+    }
+    if (!strippedString.empty()) {
+      floatStringRef = strippedString;
+    }
+  }
+
+  return Result.convertFromString(floatStringRef,
                                   APFloat::rmNearestTiesToEven);
 }
 
@@ -926,7 +977,8 @@
       ++ThisTokBuf;
     }
 
-    assert(ThisTokBuf[0] == '"' && "Expected quote, lexer broken?");
+    if (!Features.Eero)
+      assert(ThisTokBuf[0] == '"' && "Expected quote, lexer broken?");
     ++ThisTokBuf;
 
     // Check if this is a pascal string
Index: lib/Driver/Tools.cpp
===================================================================
--- lib/Driver/Tools.cpp	(revision 129311)
+++ lib/Driver/Tools.cpp	(working copy)
@@ -2061,7 +2061,7 @@
   case types::TY_C: case types::TY_CHeader:
   case types::TY_PP_C: case types::TY_PP_CHeader:
     return "cc1";
-  case types::TY_ObjC: case types::TY_ObjCHeader:
+  case types::TY_ObjC: case types::TY_Eero: case types::TY_ObjCHeader:
   case types::TY_PP_ObjC: case types::TY_PP_ObjCHeader:
     return "cc1obj";
   case types::TY_CXX: case types::TY_CXXHeader:
Index: lib/Driver/Types.cpp
===================================================================
--- lib/Driver/Types.cpp	(revision 129311)
+++ lib/Driver/Types.cpp	(working copy)
@@ -78,7 +78,7 @@
   case TY_Asm:
   case TY_C: case TY_PP_C:
   case TY_CL:
-  case TY_ObjC: case TY_PP_ObjC:
+  case TY_ObjC: case TY_PP_ObjC: case TY_Eero:
   case TY_CXX: case TY_PP_CXX:
   case TY_ObjCXX: case TY_PP_ObjCXX:
   case TY_CHeader: case TY_PP_CHeader:
@@ -109,7 +109,7 @@
   default:
     return false;
 
-  case TY_ObjC: case TY_PP_ObjC:
+  case TY_ObjC: case TY_PP_ObjC: case TY_Eero:
   case TY_ObjCXX: case TY_PP_ObjCXX:
   case TY_ObjCHeader: case TY_PP_ObjCHeader:
   case TY_ObjCXXHeader: case TY_PP_ObjCXXHeader:
@@ -135,6 +135,7 @@
            .Case("c", TY_C)
            .Case("i", TY_PP_C)
            .Case("m", TY_ObjC)
+           .Case("ero", TY_Eero)
            .Case("M", TY_ObjCXX)
            .Case("h", TY_CHeader)
            .Case("C", TY_CXX)
Index: lib/Parse/ParseDecl.cpp
===================================================================
--- lib/Parse/ParseDecl.cpp	(revision 129311)
+++ lib/Parse/ParseDecl.cpp	(working copy)
@@ -37,6 +37,7 @@
 
   // Parse the abstract-declarator, if present.
   Declarator DeclaratorInfo(DS, Context);
+  if (!getLang().Eero || !Tok.isAtStartOfLine())
   ParseDeclarator(DeclaratorInfo);
   if (Range)
     *Range = DeclaratorInfo.getSourceRange();
@@ -399,8 +400,9 @@
 
   // C99 6.7.2.3p6: Handle "struct-or-union identifier;", "enum { X };"
   // declaration-specifiers init-declarator-list[opt] ';'
-  if (Tok.is(tok::semi)) {
-    if (RequireSemi) ConsumeToken();
+  if (Tok.is(tok::semi) || 
+      (getLang().Eero && Tok.isAtStartOfLine() && !InSystemHeader(Tok.getLocation()))) {
+    if (Tok.is(tok::semi) && RequireSemi) ConsumeToken();
     Decl *TheDecl = Actions.ParsedFreeStandingDeclSpec(getCurScope(), AS_none,
                                                            DS);
     DS.complete(TheDecl);
@@ -498,6 +500,7 @@
     *DeclEnd = Tok.getLocation();
 
   if (Context != Declarator::ForContext &&
+      !getLang().Eero &&
       ExpectAndConsume(tok::semi,
                        Context == Declarator::FileContext
                          ? diag::err_invalid_token_after_toplevel_declarator
@@ -511,6 +514,11 @@
         ConsumeToken();
     }
   }
+  if (getLang().Eero &&
+      Context != Declarator::ForContext &&
+      Tok.is(tok::semi)) {
+    ConsumeToken();
+  }
 
   return Actions.FinalizeDeclaratorGroup(getCurScope(), DS,
                                          DeclsInGroup.data(),
@@ -890,6 +898,7 @@
                                         DeclSpecContext DSContext) {  
   DS.SetRangeStart(Tok.getLocation());
   DS.SetRangeEnd(Tok.getLocation());
+  bool firstPass = true;
   while (1) {
     bool isInvalid = false;
     const char *PrevSpec = 0;
@@ -897,6 +906,16 @@
 
     SourceLocation Loc = Tok.getLocation();
 
+    if (getLang().Eero && 
+        !firstPass && 
+        Tok.isAtStartOfLine() && 
+        !InSystemHeader(Loc)) {
+      goto DoneWithDeclSpec; // !!! a goto? !!!
+    }
+
+    if (firstPass)
+      firstPass = false;
+
     switch (Tok.getKind()) {
     default:
     DoneWithDeclSpec:
@@ -1231,6 +1250,13 @@
     case tok::kw_typedef:
       isInvalid = DS.SetStorageClassSpec(DeclSpec::SCS_typedef, Loc, PrevSpec,
                                          DiagID, getLang());
+      // Eero strict enum declaration "typedef { A, B, C} TypeName"
+      if (getLang().Eero && NextToken().is(tok::l_brace)) {
+        DS.SetRangeEnd(Tok.getLocation());
+        ConsumeToken(); // typedef
+        ParseEnumSpecifier(Loc, DS, TemplateInfo, AS_none, true /*strict*/ );
+        continue;
+      }
       break;
     case tok::kw_extern:
       if (DS.isThreadSpecified())
@@ -1249,7 +1275,7 @@
                                          DiagID, getLang());
       break;
     case tok::kw_auto:
-      if (getLang().CPlusPlus0x || getLang().ObjC2) {
+      if (getLang().CPlusPlus0x) {
         if (isKnownToBeTypeSpecifier(GetLookAheadToken(1))) {
           isInvalid = DS.SetStorageClassSpec(DeclSpec::SCS_auto, Loc, PrevSpec,
                                            DiagID, getLang());
@@ -1905,10 +1931,10 @@
 
     if (Tok.is(tok::semi)) {
       ConsumeToken();
-    } else if (Tok.is(tok::r_brace)) {
+    } else if (Tok.is(tok::r_brace) && !getLang().Eero) {
       ExpectAndConsume(tok::semi, diag::ext_expected_semi_decl_list);
       break;
-    } else {
+    } else if (!getLang().Eero) {
       ExpectAndConsume(tok::semi, diag::err_expected_semi_decl_list);
       // Skip to end of block or statement to avoid ext-warning on extra ';'.
       SkipUntil(tok::r_brace, true, true);
@@ -1929,6 +1955,10 @@
                       attrs.getList());
   StructScope.Exit();
   Actions.ActOnTagFinishDefinition(getCurScope(), TagDecl, RBraceLoc);
+
+  if (getLang().Eero && Tok.isAtStartOfLine() && !InSystemHeader(RBraceLoc)) {
+    InsertToken(tok::semi);
+  }
 }
 
 /// ParseEnumSpecifier
@@ -1960,7 +1990,7 @@
 ///
 void Parser::ParseEnumSpecifier(SourceLocation StartLoc, DeclSpec &DS,
                                 const ParsedTemplateInfo &TemplateInfo,
-                                AccessSpecifier AS) {
+                                AccessSpecifier AS, bool Strict) {
   // Parse the tag portion of this.
   if (Tok.is(tok::code_completion)) {
     // Code completion for an enum name.
@@ -2170,7 +2200,7 @@
   }
   
   if (Tok.is(tok::l_brace))
-    ParseEnumBody(StartLoc, TagDecl);
+    ParseEnumBody(StartLoc, TagDecl, Strict);
 
   // FIXME: The DeclSpec should keep the locations of both the keyword
   // and the name (if there is one).
@@ -2189,7 +2219,7 @@
 ///       enumeration-constant:
 ///         identifier
 ///
-void Parser::ParseEnumBody(SourceLocation StartLoc, Decl *EnumDecl) {
+void Parser::ParseEnumBody(SourceLocation StartLoc, Decl *EnumDecl, bool Strict) {
   // Enter the scope of the enum body and start the definition.
   ParseScope EnumScope(this, Scope::DeclScope);
   Actions.ActOnTagStartDefinition(getCurScope(), EnumDecl);
@@ -2204,6 +2234,10 @@
 
   Decl *LastEnumConstDecl = 0;
 
+  if (getLang().Eero && Strict) {
+    Actions.SetEnumAsStrict(EnumDecl);
+  }
+
   // Parse the enumerator-list.
   while (Tok.is(tok::identifier)) {
     IdentifierInfo *Ident = Tok.getIdentifierInfo();
@@ -2218,10 +2252,24 @@
     if (Tok.is(tok::equal)) {
       EqualLoc = ConsumeToken();
       AssignedVal = ParseConstantExpression();
+      if (getLang().Eero && Strict) { // not allowed for Eero strict enums
+        Diag(EqualLoc, diag::err_expected_comma);
+        AssignedVal = ExprError();
+      }
       if (AssignedVal.isInvalid())
         SkipUntil(tok::comma, tok::r_brace, true, true);
     }
 
+    // Strict enums start at 1 (for now, at dev's discretion).
+    if (getLang().Eero && Strict && !LastEnumConstDecl) {
+      Token One;
+      One.setKind(tok::numeric_constant);
+      One.setLiteralData("1");
+      One.setLength(1);
+      One.setLocation(IdentLoc);
+      AssignedVal = Actions.ActOnNumericConstant(One);      
+    }
+
     // Install the enumerator constant into EnumDecl.
     Decl *EnumConstDecl = Actions.ActOnEnumConstant(getCurScope(), EnumDecl,
                                                     LastEnumConstDecl,
@@ -2392,7 +2440,7 @@
 
     // GNU ObjC bizarre protocol extension: <proto1,proto2> with implicit 'id'.
   case tok::less:
-    return getLang().ObjC1;
+    return getLang().ObjC1 && !getLang().Eero;
 
   case tok::kw___cdecl:
   case tok::kw___stdcall:
@@ -2420,6 +2468,18 @@
       return false;
     if (TryAltiVecVectorToken())
       return true;
+    if (getLang().Eero && DisambiguatingWithExpression &&
+        !GetLookAheadToken(1).isAtStartOfLine() &&
+        ((GetLookAheadToken(1).is(tok::identifier) &&  // method call with arg(s)
+          !GetLookAheadToken(2).isAtStartOfLine() &&   //
+          GetLookAheadToken(2).isNot(tok::equal) &&
+          GetLookAheadToken(2).isNot(tok::comma) &&
+          GetLookAheadToken(2).isNot(tok::semi) &&
+          (GetLookAheadToken(2).isNot(tok::identifier) ||
+           GetLookAheadToken(2).getIdentifierInfo() != ObjCTypeQuals[objc_in])) ||
+         GetLookAheadToken(1).is(tok::colon))) {       // class method call
+      return false;
+    }
     // Fall through.
   case tok::kw_typename: // typename T::type
     // Annotate typenames and C++ scope specifiers.  If we get one, just
@@ -2453,6 +2513,10 @@
 
     // storage-class-specifier
   case tok::kw_typedef:
+    if (getLang().Eero && 
+        GetLookAheadToken(1).is(tok::identifier) && 
+        GetLookAheadToken(2).is(tok::ellipsis) && 
+        GetLookAheadToken(3).is(tok::ellipsis) ) {  return false; }
   case tok::kw_extern:
   case tok::kw___private_extern__:
   case tok::kw_static:
@@ -2512,7 +2576,7 @@
 
     // GNU ObjC bizarre protocol extension: <proto1,proto2> with implicit 'id'.
   case tok::less:
-    return getLang().ObjC1;
+    return getLang().ObjC1 && !getLang().Eero;
 
   case tok::kw___declspec:
   case tok::kw___cdecl:
@@ -2979,7 +3043,9 @@
   if (D.getIdentifier())
     MaybeParseCXX0XAttributes(D);
 
-  while (1) {
+  while (!getLang().Eero || 
+         !Tok.isAtStartOfLine() || 
+         InSystemHeader(Tok.getLocation())) {
     if (Tok.is(tok::l_paren)) {
       // The paren may be part of a C++ direct initializer, eg. "int x(1);".
       // In such a case, check if we actually have a function declarator; if it
@@ -3018,6 +3084,18 @@
   SourceLocation StartLoc = ConsumeParen();
   assert(!D.isPastIdentifier() && "Should be called before passing identifier");
 
+  // Support Eero compact blocks: "^(int x | <expr_or_return_stmt>)",
+  // in this case handling "^(| <expr_or_return_stmt>)"
+  if (getLang().Eero && Tok.is(tok::pipe) && 
+      (D.getContext() == Declarator::BlockLiteralContext)) {
+
+    unsigned SavedTokLen = Tok.getLength();
+    Tok.setLength(0);            // mark the pipe token as "inserted"
+    PP.EnterToken(Tok);          // push the pipe forward
+    Tok.setKind(tok::r_paren);   // make the orig pipe a r_paren
+    Tok.setLength(SavedTokLen);  // restore orig's len (used by Decl)
+  }
+
   // Eat any attributes before we look at whether this is a grouping or function
   // declarator paren.  If this is a grouping paren, the attribute applies to
   // the type being built up, for example:
@@ -3381,6 +3459,16 @@
             << FixItHint::CreateInsertion(EllipsisLoc, ", ");
         }
       }
+
+      // Support Eero compact blocks: "^(int x | <expr_or_return_stmt>)"
+      if (getLang().Eero && Tok.is(tok::pipe) && 
+          (D.getContext() == Declarator::BlockLiteralContext)) {
+        unsigned SavedTokLen = Tok.getLength();
+        Tok.setLength(0);            // mark the pipe token as "inserted"
+        PP.EnterToken(Tok);          // push the pipe forward
+        Tok.setKind(tok::r_paren);   // make the orig pipe a r_paren
+        Tok.setLength(SavedTokLen);  // restore orig's len (used by Decl)
+      }
       
       break;
     }
Index: lib/Parse/ParseObjc.cpp
===================================================================
--- lib/Parse/ParseObjc.cpp	(revision 129311)
+++ lib/Parse/ParseObjc.cpp	(working copy)
@@ -18,6 +18,7 @@
 #include "clang/Sema/PrettyDeclStackTrace.h"
 #include "clang/Sema/Scope.h"
 #include "llvm/ADT/SmallVector.h"
+#include "clang/AST/ASTConsumer.h"
 using namespace clang;
 
 
@@ -92,7 +93,7 @@
   }
 
   // Consume the ';'.
-  if (ExpectAndConsume(tok::semi, diag::err_expected_semi_after, "@class"))
+  if (!getLang().Eero && ExpectAndConsume(tok::semi, diag::err_expected_semi_after, "@class"))
     return 0;
 
   return Actions.ActOnForwardClassDeclaration(atLoc, ClassNames.data(),
@@ -325,12 +326,20 @@
 
   while (1) {
     // If this is a method prototype, parse it.
-    if (Tok.is(tok::minus) || Tok.is(tok::plus)) {
+    if ((Tok.is(tok::minus) || Tok.is(tok::plus)) ||
+        (getLang().Eero && 
+         Tok.getObjCKeywordID() == tok::objc_not_keyword &&
+         (Tok.is(tok::identifier) || Tok.is(tok::kw_static)))) {
       Decl *methodPrototype =
         ParseObjCMethodPrototype(interfaceDecl, MethodImplKind);
       allMethods.push_back(methodPrototype);
       // Consume the ';' here, since ParseObjCMethodPrototype() is re-used for
       // method definitions.
+      if (getLang().Eero) {
+        if (Tok.is(tok::semi))
+          ConsumeToken();
+        continue;
+      }
       ExpectAndConsume(tok::semi, diag::err_expected_semi_after_method_proto,
                        "", tok::semi);
       continue;
@@ -362,7 +371,7 @@
     }
     
     // If we don't have an @ directive, parse it as a function definition.
-    if (Tok.isNot(tok::at)) {
+    if (Tok.isNot(tok::at) && (!getLang().Eero || InSystemHeader(Tok.getLocation()))) {
       // The code below does not consume '}'s because it is afraid of eating the
       // end of a namespace.  Because of the way this code is structured, an
       // erroneous r_brace would cause an infinite loop if not handled here.
@@ -377,7 +386,12 @@
     }
 
     // Otherwise, we have an @ directive, eat the @.
-    SourceLocation AtLoc = ConsumeToken(); // the "@"
+    SourceLocation AtLoc;
+    if (!getLang().Eero) {
+      AtLoc = ConsumeToken(); // the "@"
+    } else { // optional for Eero
+      AtLoc = Tok.is(tok::at)? ConsumeToken() : Tok.getLocation(); // the "@"
+    }
     if (Tok.is(tok::code_completion)) {
       Actions.CodeCompleteObjCAtDirective(getCurScope(), ObjCImpDecl, true);
       ConsumeCodeCompletionToken();
@@ -442,6 +456,12 @@
       DeclSpec DS;
       ParseStructDeclaration(DS, Callback);
 
+      if (getLang().Eero) {
+        if (Tok.is(tok::semi))
+          ConsumeToken();
+        break;
+      } 
+
       ExpectAndConsume(tok::semi, diag::err_expected_semi_decl_list, "",
                        tok::at);
       break;
@@ -583,10 +603,18 @@
 ///
 Decl *Parser::ParseObjCMethodPrototype(Decl *IDecl,
                                        tok::ObjCKeywordKind MethodImplKind) {
-  assert((Tok.is(tok::minus) || Tok.is(tok::plus)) && "expected +/-");
+  if (!getLang().Eero)
+    assert((Tok.is(tok::minus) || Tok.is(tok::plus)) && "expected +/-");
 
-  tok::TokenKind methodType = Tok.getKind();
-  SourceLocation mLoc = ConsumeToken();
+  tok::TokenKind methodType;
+  SourceLocation mLoc;  
+  if (!getLang().Eero || Tok.is(tok::minus) || Tok.is(tok::plus)) {
+    methodType = Tok.getKind();
+    mLoc = ConsumeToken();
+  } else {
+    methodType = tok::unknown;
+    mLoc = Tok.getLocation();
+  }
   Decl *MDecl = ParseObjCMethodDecl(mLoc, methodType, IDecl,MethodImplKind);
   // Since this rule is used for both method declarations and definitions,
   // the caller is (optionally) responsible for consuming the ';'.
@@ -698,6 +726,10 @@
   case tok::kw___alignof:
     IdentifierInfo *II = Tok.getIdentifierInfo();
     SelectorLoc = ConsumeToken();
+    // Eero treats selector name "_" as an unnamed selector
+    if (getLang().Eero && 
+        (II->getLength() == 1 && *(II->getNameStart()) == '_' ))
+      II = 0;  // TODO: make sure not a leak
     return II;
   }
 }
@@ -761,9 +793,11 @@
 ///     '(' objc-type-qualifiers[opt] ')'
 ///
 ParsedType Parser::ParseObjCTypeName(ObjCDeclSpec &DS, bool IsParameter) {
-  assert(Tok.is(tok::l_paren) && "expected (");
+  assert(getLang().Eero || Tok.is(tok::l_paren) && "expected (");
 
-  SourceLocation LParenLoc = ConsumeParen();
+  // Note: Eero supports ObjC prototypes for header compatibility
+  SourceLocation LParenLoc = !getLang().Eero || Tok.is(tok::l_paren) ? ConsumeParen() 
+                                                                     : SourceLocation();
   SourceLocation TypeStartLoc = Tok.getLocation();
 
   // Parse type qualifiers, in, inout, etc.
@@ -776,6 +810,12 @@
       Ty = TypeSpec.get();
   }
 
+  if (!LParenLoc.isValid()) {
+    if (Ty == 0)
+      Diag(TypeStartLoc, diag::err_expected_type);
+    return Ty;
+  }
+
   if (Tok.is(tok::r_paren))
     ConsumeParen();
   else if (Tok.getLocation() == TypeStartLoc) {
@@ -790,6 +830,49 @@
   return Ty;
 }
 
+/// Eero helper function which derives a variable name from a camel case 
+/// selector name (full name begins with lowercase characters, new 
+/// words start with uppercase characters).
+/// The variable name construction rules are: 
+///   1) If the selector name contains words separated by camel case, then the
+///      last word (scanning left to right), converted entirely to lowercase, is used.
+///   2) The first camel case word containing two consecutive uppercase characters
+///      encountered (scanning left to right) is used, along with all subsequent 
+///      words; no character cases are modified.
+///   3) If no uppercase characters are encountered, the entire selector name is used.
+///   4) If the first character in the selector name is uppercase, the entire selector 
+///      name is used.
+///
+/// Examples:
+///   1) Selector name "initWithString" results in variable name "string"
+///   2) Selector name "initWithUTF8String" results in variable name "UTF8String"
+///   3) Selector name "compare" results in variable name "compare"
+///   4) Selector name "CreateNewString" results in variable name "CreateNewString"
+///
+static std::string NameFromCamelCase(const std::string& aName)
+{
+  std::string name(aName);
+  size_t pos(std::string::npos);
+  bool changeCase(true);
+  
+  for (size_t i=0; i < name.length(); i++) {          
+    if (isupper(name[i])) {
+      if (i == pos + 1) {  // two consecutive uppercase chars (or if name begins with uppercase)
+        changeCase = false;
+        break;
+      } else {
+        pos = i;
+      }
+    }
+  }
+  if (pos != std::string::npos) {
+    if (changeCase)
+      name[pos] = tolower(name[pos]);
+    name = name.substr(pos);
+  }
+  return name;
+}
+
 ///   objc-method-decl:
 ///     objc-selector
 ///     objc-keyword-selector objc-parmlist[opt]
@@ -824,17 +907,32 @@
                                   tok::ObjCKeywordKind MethodImplKind) {
   ParsingDeclRAIIObject PD(*this);
 
+  bool objcSyntax(true);
+  if (getLang().Eero && mType == tok::unknown) {    
+    objcSyntax = false;
+    if (Tok.is(tok::kw_static)) {
+      ConsumeToken();
+      mType = tok::plus;
+    } else {
+      mType = tok::minus;
+    }
+  }
+
   if (Tok.is(tok::code_completion)) {
     Actions.CodeCompleteObjCMethodDecl(getCurScope(), mType == tok::minus, 
                                        /*ReturnType=*/ ParsedType(), IDecl);
     ConsumeCodeCompletionToken();
   }
 
-  // Parse the return type if present.
   ParsedType ReturnType;
   ObjCDeclSpec DSRet;
-  if (Tok.is(tok::l_paren))
+  if (objcSyntax) { // Parse the return type if present.
+    if (Tok.is(tok::l_paren))
+      ReturnType = ParseObjCTypeName(DSRet, false);
+  } else { // Eero return type defaults to void    
+    InsertToken(tok::kw_void); // look into a cleaner way to do this
     ReturnType = ParseObjCTypeName(DSRet, false);
+  }
 
   // If attributes exist before the method, parse them.
   ParsedAttributes attrs;
@@ -852,7 +950,7 @@
   IdentifierInfo *SelIdent = ParseObjCSelectorPiece(selLoc);
 
   // An unnamed colon is valid.
-  if (!SelIdent && Tok.isNot(tok::colon)) { // missing selector name.
+  if (objcSyntax && !SelIdent && Tok.isNot(tok::colon)) { // missing selector name.
     Diag(Tok, diag::err_expected_selector_for_method)
       << SourceRange(mLoc, Tok.getLocation());
     // Skip until we get a ; or {}.
@@ -860,8 +958,27 @@
     return 0;
   }
 
+  bool doneParsing = false;  
+  if (objcSyntax) {
+    if (Tok.isNot(tok::colon))
+      doneParsing = true;
+  } else if (SelIdent) { // Eero syntax, not unnamed
+    if (Tok.isAtStartOfLine() || Tok.is(tok::kw___attribute)) {
+      doneParsing = true;
+    } else if (Tok.is(tok::comma) && NextToken().is(tok::kw_return)) {
+      doneParsing = true;
+      ConsumeToken(); // comma
+      SourceLocation retLoc = ConsumeToken(); // return
+      if (!Tok.isAtStartOfLine()) {
+        ReturnType = ParseObjCTypeName(DSRet, false);
+      } else {
+        Diag(PP.getLocForEndOfToken(retLoc), diag::err_expected_type);
+      }
+    }
+  }
+
   llvm::SmallVector<DeclaratorChunk::ParamInfo, 8> CParamInfo;
-  if (Tok.isNot(tok::colon)) {
+  if (doneParsing) {
     // If attributes exist after the method, parse them.
     if (getLang().ObjC2)
       MaybeParseGNUAttributes(attrs);
@@ -881,19 +998,46 @@
   llvm::SmallVector<Sema::ObjCArgInfo, 12> ArgInfos;
   ParseScope PrototypeScope(this,
                             Scope::FunctionPrototypeScope|Scope::DeclScope);
+  bool isVariadic = false;
+  const bool inImplementation = !PendingObjCImpDecl.empty();
+
+  // For Eero optional method parameters
+  bool isOptional = false;
+  SourceLocation LBracketLoc;
+  unsigned OptionalParamsCount = 0;
+  llvm::SmallVector<bool, 12> IsParamOptionalFlags;
+  llvm::SmallVector<UnqualifiedId, 12> ArgIds;
+  llvm::SmallVector<ExprResult, 12> DefaultExprs;
+
   
   while (1) {
     Sema::ObjCArgInfo ArgInfo;
 
     // Each iteration parses a single keyword argument.
-    if (Tok.isNot(tok::colon)) {
+    if (objcSyntax && Tok.isNot(tok::colon)) {
       Diag(Tok, diag::err_expected_colon);
       break;
     }
-    ConsumeToken(); // Eat the ':'.
+    if (objcSyntax) {
+      ConsumeToken(); // Eat the ':'.
+    } else if (Tok.is(tok::pipe)) { // Eero, a variable name has been specified
+      // TODO: Break this out as a function for re-use
+      ConsumeToken(); // "|"
+      if (Tok.isNot(tok::identifier)) {
+        Diag(Tok, diag::err_expected_ident); // missing argument name.
+        break;
+      }
+      ArgInfo.Name = Tok.getIdentifierInfo();
+      ArgInfo.NameLoc = ConsumeToken(); // Eat the arg name identifier
+      if (Tok.is(tok::pipe)) // closing vert bar is optional
+        ConsumeToken(); // "|"
+    } else { // Eero, name not specified before type
+      ArgInfo.Name = 0;
+    }
 
+    SourceLocation ArgTypeLoc = Tok.getLocation();
     ArgInfo.Type = ParsedType();
-    if (Tok.is(tok::l_paren)) // Parse the argument type if present.
+    if (Tok.is(tok::l_paren) || !objcSyntax) // Parse the argument type if present.
       ArgInfo.Type = ParseObjCTypeName(ArgInfo.DeclSpec, true);
 
     // If attributes exist before the argument name, parse them.
@@ -917,19 +1061,109 @@
       KeyIdents.pop_back();
       break;
     }
-    
-    if (Tok.isNot(tok::identifier)) {
-      Diag(Tok, diag::err_expected_ident); // missing argument name.
-      break;
+
+    if (objcSyntax) {
+      if (Tok.isNot(tok::identifier)) {
+        Diag(Tok, diag::err_expected_ident); // missing argument name.
+        break;
+      }
+      ArgInfo.Name = Tok.getIdentifierInfo();
+      ArgInfo.NameLoc = Tok.getLocation();
+      ConsumeToken(); // Eat the identifier.
+    } else { // Eero syntax
+      // Determine variable name
+      if (ArgInfo.Name == 0) { // was name already defined?
+        if (Tok.is(tok::pipe)) { // is being specified
+          // TODO: Break this out as a function for re-use
+          ConsumeToken(); // "|"
+          if (Tok.isNot(tok::identifier)) {
+            Diag(Tok, diag::err_expected_ident); // missing argument name.
+            break;
+          }
+          ArgInfo.Name = Tok.getIdentifierInfo();
+          ArgInfo.NameLoc = ConsumeToken(); // Eat the arg name identifier
+          if (Tok.is(tok::pipe)) // closing vert bar is optional
+            ConsumeToken(); // "|"
+        } else { // default name
+          std::string generatedName;
+          // derive arg var name from selector piece
+          if (SelIdent)
+            generatedName = NameFromCamelCase(SelIdent->getName());
+          else
+            generatedName = "_";
+          if (!inImplementation) {
+            // make the name unique to avoid compiler warnings:
+            // name, name1, name2, ..., Name0 
+            if (ArgInfos.size() > 0)
+              generatedName += ('0' + ArgInfos.size() % 10);
+          }
+          ArgInfo.Name = &PP.getIdentifierTable().get(generatedName);
+          ArgInfo.NameLoc = ArgTypeLoc;
+        }
+      }
+      // Eero optional parameter close
+      if (!objcSyntax && isOptional) {
+        MatchRHSPunctuation(tok::r_square, LBracketLoc);
+      }
+      if (!objcSyntax && inImplementation) {
+        if (Tok.is(tok::equal)) {
+          ConsumeToken(); // "="
+          isOptional = true;
+          DefaultExprs.push_back(ParseAssignmentExpression());          
+        }
+        UnqualifiedId ArgName;
+        ArgName.setIdentifier(ArgInfo.Name, ArgInfo.NameLoc);
+        ArgIds.push_back(ArgName);
+      }
+      
+      // Eero requires comma to continue parsing args
+      if (Tok.is(tok::comma)) {
+        ConsumeToken(); // Eat the ','.
+        doneParsing = false;
+      } else {
+        doneParsing = true;
+      }
+      if (Tok.is(tok::ellipsis)) { // variadic args
+        if (!doneParsing) { // requires a comma first
+          isVariadic = true;
+          ConsumeToken(); // eat the "..." token
+          if (Tok.is(tok::comma)) { // only for a return
+            ConsumeToken(); // Eat the ','.
+            if (Tok.isNot(tok::kw_return)) // must be return
+              Diag(Tok.getLocation(), diag::err_expected) << "return";
+          } else { // no trailing comma
+            doneParsing = true;
+          }
+        } else {      
+          Diag(Tok, diag::err_expected_comma);
+        }
+      }
+      if (!doneParsing && Tok.is(tok::kw_return)) {
+        doneParsing = true;
+        SourceLocation retLoc = ConsumeToken(); // Eat the 'return'
+        if (!Tok.isAtStartOfLine())
+          ReturnType = ParseObjCTypeName(DSRet, false);
+        else
+          Diag(PP.getLocForEndOfToken(retLoc), diag::err_expected_type);
+      }
     }
 
-    ArgInfo.Name = Tok.getIdentifierInfo();
-    ArgInfo.NameLoc = Tok.getLocation();
-    ConsumeToken(); // Eat the identifier.
-
     ArgInfos.push_back(ArgInfo);
     KeyIdents.push_back(SelIdent);
 
+    if (!objcSyntax) {
+      if (isOptional) { // if optional parameter
+        IsParamOptionalFlags.push_back(true);
+        OptionalParamsCount++;
+        isOptional = false;
+      } else {
+        IsParamOptionalFlags.push_back(false);
+      }
+    }
+
+    if (doneParsing)
+      break;
+
     // Code completion for the next piece of the selector.
     if (Tok.is(tok::code_completion)) {
       ConsumeCodeCompletionToken();
@@ -941,17 +1175,24 @@
                                                  KeyIdents.size());
       break;
     }
+
+    // Check if specifying optional parameter
+    if (!objcSyntax && Tok.is(tok::l_square) && 
+        !inImplementation &&         // only non-implementations
+        ArgInfos.size() > 0 &&       // cannot be first parameter
+        NextToken().isNot(tok::kw_return)) { // cannot be return
+      LBracketLoc = ConsumeBracket();
+      isOptional = true;
+    }
     
     // Check for another keyword selector.
     SourceLocation Loc;
     SelIdent = ParseObjCSelectorPiece(Loc);
-    if (!SelIdent && Tok.isNot(tok::colon))
+    if (objcSyntax && !SelIdent && Tok.isNot(tok::colon))
       break;
     // We have a selector or a colon, continue parsing.
   }
 
-  bool isVariadic = false;
-
   // Parse the (optional) parameter list.
   while (Tok.is(tok::comma)) {
     ConsumeToken();
@@ -996,7 +1237,122 @@
                                         MethodImplKind, isVariadic);
   // Leave prototype scope.
   PrototypeScope.Exit();
+
+  // Eero support for optional parameters.
+  // TODO: this function was already too big before adding all this...
+
+  // List to be consumed during looping
+  llvm::SmallVector<bool, 12> IsParamOptional;
+
+  // "self" identifier, for generated method body message
+  UnqualifiedId SelfName;
+  CXXScopeSpec EmptyScopeSpec;
+
+  if (!objcSyntax && OptionalParamsCount) {
+    IsParamOptional = IsParamOptionalFlags;
+    IdentifierInfo &SelfII = PP.getIdentifierTable().getOwn("self"); 
+    SelfName.setIdentifier(&SelfII, SourceLocation());
+  }
   
+  while (!objcSyntax && OptionalParamsCount) {
+
+    // Note: Start with 1 since first parameter cannot be optional
+    for (unsigned i = 1; i < ArgInfos.size(); i++) {
+
+      if (IsParamOptional[i]) {  // if an optional parameter
+
+        ParsingDeclRAIIObject OptPD(*this);
+        ParseScope OptPrototypeScope(this,
+                                  Scope::FunctionPrototypeScope|Scope::DeclScope);
+        OptionalParamsCount--;
+
+        IsParamOptional.erase(IsParamOptional.begin() + i);
+        KeyIdents.erase(KeyIdents.begin() + i);
+        ArgInfos.erase(ArgInfos.begin() + i);
+             
+        Selector PartialSel = PP.getSelectorTable().getSelector(KeyIdents.size(),
+                                                   &KeyIdents[0]);
+
+        Decl *OptDecl = Actions.ActOnMethodDeclaration(
+                                      getCurScope(), mLoc, Tok.getLocation(),
+                                      mType, IDecl, DSRet, ReturnType, PartialSel,
+                                      &ArgInfos[0], 
+                                      CParamInfo.data(), CParamInfo.size(),
+                                      attrs.getList(),
+                                      MethodImplKind, isVariadic);
+        OptPrototypeScope.Exit();
+        OptPD.complete(OptDecl);
+
+        if (inImplementation) { // generate methods for optional parameters
+           
+          // Enter a scope for the method body.
+          ParseScope BodyScope(this,
+                               Scope::ObjCMethodScope|Scope::FnScope|Scope::DeclScope);
+
+          // Tell the actions module that we have entered a method definition with the
+          // specified Declarator for the method.
+          Actions.ActOnStartOfObjCMethodDef(getCurScope(), OptDecl);
+
+          // Build list of argument expressions for generated method body,
+          // which will be a message sent to self.
+          //
+          ExprVector ArgExprs(Actions);
+          bool doneReplacingThisPass = false; // just one replacement per pass
+          for (unsigned j = 0, k = 0; j < ArgIds.size(); j++) {
+            if (!doneReplacingThisPass && 
+                IsParamOptionalFlags[j] && 
+                ArgIds[j].isValid()) {
+              ArgIds[j].clear(); // "consume" the default parameter name
+              doneReplacingThisPass = true;
+            }
+            if (ArgIds[j].isValid()) { // use the parameter variable name
+              ArgExprs.push_back(
+                  Actions.ActOnIdExpression(getCurScope(), 
+                                            EmptyScopeSpec,
+                                            ArgIds[j], false, false).take());
+            } else { // use the parameter default expression
+              ExprResult DefaultExpr = DefaultExprs[k++];
+              if (!DefaultExpr.isInvalid())
+                ArgExprs.push_back(DefaultExpr.get());               
+            }
+          }
+
+          ExprResult SelfExpr = 
+              Actions.ActOnIdExpression(getCurScope(), 
+                                        EmptyScopeSpec,
+                                        SelfName, false, false);
+          ExprResult MessageExpr = 
+              Actions.ActOnInstanceMessage(getCurScope(), 
+                                           SelfExpr.get(), 
+                                           Sel,
+                                           mLoc, mLoc, mLoc,
+                                           MultiExprArg(Actions, 
+                                                        ArgExprs.take(), 
+                                                        ArgExprs.size()));
+          StmtResult FnBody;
+          if (MessageExpr.isInvalid())
+            FnBody = StmtError();
+          else if (Actions.GetTypeFromParser(ReturnType)->isVoidType())
+            FnBody = StmtResult(MessageExpr.take());
+          else
+            FnBody = Actions.ActOnReturnStmt(mLoc, MessageExpr.take());
+
+          // If the function body could not built, make a bogus compoundstmt.
+          if (FnBody.isInvalid())
+              FnBody = Actions.ActOnCompoundStmt(mLoc, mLoc,
+                                                 MultiStmtArg(Actions), false);
+          // Leave the function body scope.
+          BodyScope.Exit();
+
+          Actions.ActOnFinishFunctionBody(OptDecl, FnBody.take());
+
+          DeclGroupPtrTy DGroup = Actions.ConvertDeclToDeclGroup(OptDecl);
+          Actions.Consumer.HandleTopLevelDecl(DGroup.get());
+        }
+      }
+    }  
+  }
+ 
   PD.complete(Result);
   return Result;
 }
@@ -1113,14 +1469,20 @@
     }
 
     // Set the default visibility to private.
+    bool foundAtKeyword(false);
     if (Tok.is(tok::at)) { // parse objc-visibility-spec
       ConsumeToken(); // eat the @ sign
-      
+      foundAtKeyword = true;
       if (Tok.is(tok::code_completion)) {
         Actions.CodeCompleteObjCAtVisibility(getCurScope());
         ConsumeCodeCompletionToken();
       }
+    }
       
+    if (foundAtKeyword || 
+        (getLang().Eero && 
+         Tok.getObjCKeywordID() != tok::objc_not_keyword)) { // it is an objc keyword
+
       switch (Tok.getObjCKeywordID()) {
       case tok::objc_private:
       case tok::objc_public:
@@ -1170,7 +1532,7 @@
 
     if (Tok.is(tok::semi)) {
       ConsumeToken();
-    } else {
+    } else if (!getLang().Eero) {
       Diag(Tok, diag::err_expected_semi_decl_list);
       // Skip to end of block or statement
       SkipUntil(tok::r_brace, true, true);
@@ -1470,7 +1832,10 @@
       break;
     ConsumeToken(); // consume ','
   }
+  if (!getLang().Eero)
   ExpectAndConsume(tok::semi, diag::err_expected_semi_after, "@synthesize");
+  else if (Tok.is(tok::semi))
+    ConsumeToken();
   return 0;
 }
 
@@ -1534,24 +1899,38 @@
 StmtResult
 Parser::ParseObjCSynchronizedStmt(SourceLocation atLoc) {
   ConsumeToken(); // consume synchronized
-  if (Tok.isNot(tok::l_paren)) {
+  if (!getLang().Eero && Tok.isNot(tok::l_paren)) {
     Diag(Tok, diag::err_expected_lparen_after) << "@synchronized";
     return StmtError();
   }
-  ConsumeParen();  // '('
+  SourceLocation LParenLoc;
+  if (Tok.is(tok::l_paren))
+    LParenLoc = ConsumeParen();  // '('
   ExprResult Res(ParseExpression());
   if (Res.isInvalid()) {
     SkipUntil(tok::semi);
     return StmtError();
   }
-  if (Tok.isNot(tok::r_paren)) {
-    Diag(Tok, diag::err_expected_lbrace);
-    return StmtError();
+  if (LParenLoc.isValid()) {
+    if (Tok.is(tok::r_paren)) {
+      ConsumeParen();  // ')'
+    } else {
+      Diag(Tok, diag::err_expected_lbrace);
+      return StmtError();
+    }
   }
-  ConsumeParen();  // ')'
   if (Tok.isNot(tok::l_brace)) {
-    Diag(Tok, diag::err_expected_lbrace);
-    return StmtError();
+    if (!getLang().Eero) {
+      Diag(Tok, diag::err_expected_lbrace);
+      return StmtError();
+    } else { // it's easiest if we just inject an opening brace
+      if (Tok.isAtStartOfLine()) {
+        InsertToken(tok::l_brace);
+      } else {
+        Diag(Tok, diag::err_expected_newline);
+        Diag(atLoc, diag::note_using);
+      }
+    }
   }
   // Enter a scope to hold everything within the compound stmt.  Compound
   // statements can always hold declarations.
@@ -1581,8 +1960,17 @@
 
   ConsumeToken(); // consume try
   if (Tok.isNot(tok::l_brace)) {
-    Diag(Tok, diag::err_expected_lbrace);
-    return StmtError();
+    if (!getLang().Eero) {
+      Diag(Tok, diag::err_expected_lbrace);
+      return StmtError();
+    } else { // it's easiest if we just inject an opening brace      
+      if (Tok.isAtStartOfLine()) {
+        InsertToken(tok::l_brace);
+      } else {
+        Diag(Tok, diag::err_expected_newline);
+        Diag(atLoc, diag::note_using);
+      }
+    }
   }
   StmtVector CatchStmts(Actions);
   StmtResult FinallyStmt;
@@ -1592,21 +1980,30 @@
   if (TryBody.isInvalid())
     TryBody = Actions.ActOnNullStmt(Tok.getLocation());
 
-  while (Tok.is(tok::at)) {
+  while (Tok.is(tok::at) || 
+         (getLang().Eero && 
+          (Tok.isObjCAtKeyword(tok::objc_catch) || 
+           Tok.isObjCAtKeyword(tok::objc_finally)))) {
     // At this point, we need to lookahead to determine if this @ is the start
     // of an @catch or @finally.  We don't want to consume the @ token if this
     // is an @try or @encode or something else.
-    Token AfterAt = GetLookAheadToken(1);
-    if (!AfterAt.isObjCAtKeyword(tok::objc_catch) &&
-        !AfterAt.isObjCAtKeyword(tok::objc_finally))
-      break;
-
-    SourceLocation AtCatchFinallyLoc = ConsumeToken();
+    SourceLocation AtCatchFinallyLoc;
+    if (!getLang().Eero || Tok.is(tok::at)) {
+      Token AfterAt = GetLookAheadToken(1);
+      if (!AfterAt.isObjCAtKeyword(tok::objc_catch) &&
+          !AfterAt.isObjCAtKeyword(tok::objc_finally))
+        break;
+      AtCatchFinallyLoc = ConsumeToken();
+    } else {
+      AtCatchFinallyLoc = Tok.getLocation();
+    }
     if (Tok.isObjCAtKeyword(tok::objc_catch)) {
       Decl *FirstPart = 0;
       ConsumeToken(); // consume catch
-      if (Tok.is(tok::l_paren)) {
-        ConsumeParen();
+      if (Tok.is(tok::l_paren) || getLang().Eero) {
+        SourceLocation LParenLoc;
+        if (Tok.is(tok::l_paren))
+          LParenLoc = ConsumeParen();
         ParseScope CatchScope(this, Scope::DeclScope|Scope::AtCatchScope);
         if (Tok.isNot(tok::ellipsis)) {
           DeclSpec DS;
@@ -1627,10 +2024,20 @@
 
         if (Tok.is(tok::r_paren))
           RParenLoc = ConsumeParen();
-        else // Skip over garbage, until we get to ')'.  Eat the ')'.
+        else if (LParenLoc.isValid()) // Skip over garbage, until we get to ')'.  Eat the ')'.
           SkipUntil(tok::r_paren, true, false);
 
         StmtResult CatchBody(true);
+        if (getLang().Eero) {
+          if (Tok.isAtStartOfLine()) {
+            InsertToken(tok::l_brace);
+          } else {
+            Diag(Tok, diag::err_expected_newline);
+            Diag(AtCatchFinallyLoc, diag::note_using);
+            while (!Tok.isAtStartOfLine()) // flush the rest of the line
+              ConsumeAnyToken();
+          }
+        }
         if (Tok.is(tok::l_brace))
           CatchBody = ParseCompoundStatementBody();
         else
@@ -1657,6 +2064,14 @@
       ParseScope FinallyScope(this, Scope::DeclScope);
 
       StmtResult FinallyBody(true);
+      if (getLang().Eero) {
+        if (Tok.isAtStartOfLine()) {
+          InsertToken(tok::l_brace);
+        } else {
+          Diag(Tok, diag::err_expected_newline);
+          Diag(AtCatchFinallyLoc, diag::note_using);
+        }
+      }
       if (Tok.is(tok::l_brace))
         FinallyBody = ParseCompoundStatementBody();
       else
@@ -1696,6 +2111,14 @@
     ConsumeToken();
   }
 
+  if (getLang().Eero) { // it's easiest if we just inject an opening brace
+    if (Tok.isAtStartOfLine()) {
+      InsertToken(tok::l_brace);
+    } else {
+      Diag(Tok, diag::err_expected_newline);
+    }
+  }
+
   // We should have an opening brace now.
   if (Tok.isNot(tok::l_brace)) {
     Diag(Tok, diag::err_expected_method_body);
@@ -1934,8 +2357,9 @@
 ///     type-name
 ///
 ExprResult Parser::ParseObjCMessageExpression() {
-  assert(Tok.is(tok::l_square) && "'[' expected");
-  SourceLocation LBracLoc = ConsumeBracket(); // consume '['
+  assert(getLang().Eero || Tok.is(tok::l_square) && "'[' expected");
+  SourceLocation LBracLoc = !getLang().Eero || InSystemHeader(PrevTokLocation) ?
+                                ConsumeBracket() : Tok.getLocation();
 
   if (Tok.is(tok::code_completion)) {
     Actions.CodeCompleteObjCMessageReceiver(getCurScope());
@@ -2082,13 +2506,33 @@
 
   llvm::SmallVector<IdentifierInfo *, 12> KeyIdents;
   ExprVector KeyExprs(Actions);
+  bool parseArguments;
 
-  if (Tok.is(tok::colon)) {
+  if (!getLang().Eero) {
+    parseArguments = Tok.is(tok::colon) ? true : false;
+  } else if (selIdent) {
+    if ((!Tok.isAtStartOfLine() || ParenCount > 0 || BracketCount > 0) &&
+        (Tok.is(tok::identifier) || 
+         Tok.isLiteral() ||
+         Tok.is(tok::l_paren)  ||
+         Tok.is(tok::caret) ||  // for block literals
+         Tok.is(tok::pipe) ||   // for selector "literals"
+         (Tok.is(tok::less) &&  // for protocol "literals"
+          GetLookAheadToken(1).is(tok::identifier) &&
+          GetLookAheadToken(2).is(tok::greater))))
+      parseArguments = true;
+    else
+      parseArguments = false;
+  } else { // unnamed method
+    parseArguments = true;
+  }
+
+  if (parseArguments) {
     while (1) {
       // Each iteration parses a single keyword argument.
       KeyIdents.push_back(selIdent);
 
-      if (Tok.isNot(tok::colon)) {
+      if (Tok.isNot(tok::colon) && !getLang().Eero) {
         Diag(Tok, diag::err_expected_colon);
         // We must manually skip to a ']', otherwise the expression skipper will
         // stop at the ']' when it skips to the ';'.  We want it to skip beyond
@@ -2097,7 +2541,7 @@
         return ExprError();
       }
 
-      ConsumeToken(); // Eat the ':'.
+      if (!getLang().Eero) ConsumeToken(); // Eat the ':'.
       ///  Parse the expression after ':'
       
       if (Tok.is(tok::code_completion)) {
@@ -2122,7 +2566,14 @@
         return ExprError();
       }
       
-      ExprResult Res(ParseAssignmentExpression());
+      ExprResult Res;
+      if (!getLang().Eero) {
+        Res = ParseAssignmentExpression();
+      } else {
+        Res = ParseCastExpression(false); // make higher prec than assignment
+        // but NSRange "..." is special, so handle it here
+        Res = ParseRangeIfPresent(Res);
+      }
       if (Res.isInvalid()) {
         // We must manually skip to a ']', otherwise the expression skipper will
         // stop at the ']' when it skips to the ';'.  We want it to skip beyond
@@ -2156,17 +2607,33 @@
         return ExprError();
       }
             
-      // Check for another keyword selector.
-      selIdent = ParseObjCSelectorPiece(Loc);
-      if (!selIdent && Tok.isNot(tok::colon))
-        break;
-      // We have a selector or a colon, continue parsing.
+      if (!getLang().Eero) {      
+        // Check for another keyword selector.
+        selIdent = ParseObjCSelectorPiece(Loc);
+        if (!selIdent && Tok.isNot(tok::colon))
+          break;
+        // We have a selector or a colon, continue parsing.
+      } else { // Eero
+        if (Tok.is(tok::comma)) {
+          if (GetLookAheadToken(1).is(tok::identifier) && // look for normal
+              GetLookAheadToken(2).isNot(tok::comma) &&   // parameter selector
+             !GetLookAheadToken(2).isAtStartOfLine()) {
+            ConsumeToken(); // consume comma
+            selIdent = ParseObjCSelectorPiece(Loc);
+          } else { // variadic args
+            break;
+          }
+        } else { // no comma, message done
+          break;
+        }
+      }
     }
     // Parse the, optional, argument list, comma separated.
     while (Tok.is(tok::comma)) {
       ConsumeToken(); // Eat the ','.
       ///  Parse the expression after ','
-      ExprResult Res(ParseAssignmentExpression());
+      ExprResult Res = !getLang().Eero ? ParseAssignmentExpression() 
+                                       : ParseCastExpression(false);      
       if (Res.isInvalid()) {
         // We must manually skip to a ']', otherwise the expression skipper will
         // stop at the ']' when it skips to the ';'.  We want it to skip beyond
@@ -2188,7 +2655,7 @@
     return ExprError();
   }
     
-  if (Tok.isNot(tok::r_square)) {
+  if (Tok.isNot(tok::r_square) && !getLang().Eero) {
     if (Tok.is(tok::identifier))
       Diag(Tok, diag::err_expected_colon);
     else
@@ -2200,7 +2667,8 @@
     return ExprError();
   }
 
-  SourceLocation RBracLoc = ConsumeBracket(); // consume ']'
+  SourceLocation RBracLoc = !getLang().Eero || InSystemHeader(PrevTokLocation) ?
+                                ConsumeBracket() : SourceLocation();
 
   unsigned nKeys = KeyIdents.size();
   if (nKeys == 0)
@@ -2284,7 +2752,13 @@
 ///       @protocol ( protocol-name )
 ExprResult
 Parser::ParseObjCProtocolExpression(SourceLocation AtLoc) {
-  SourceLocation ProtoLoc = ConsumeToken();
+  SourceLocation ProtoLoc;
+  if (!getLang().Eero || !Tok.is(tok::less)) { 
+    ProtoLoc = ConsumeToken();
+  } else {
+    ProtoLoc = Tok.getLocation();
+    Tok.setKind(tok::l_paren);
+  }
 
   if (Tok.isNot(tok::l_paren))
     return ExprError(Diag(Tok, diag::err_expected_lparen_after) << "@protocol");
@@ -2297,6 +2771,14 @@
   IdentifierInfo *protocolId = Tok.getIdentifierInfo();
   ConsumeToken();
 
+  if (ProtoLoc == LParenLoc) { // if using Eero's <> notation
+    if (Tok.is(tok::greater)) {
+      Tok.setKind(tok::r_paren);
+    } else {
+      Diag(Tok, diag::err_expected_greater);
+      return ExprError(Diag(LParenLoc, diag::note_matching) << "<");
+    }
+  }
   SourceLocation RParenLoc = MatchRHSPunctuation(tok::r_paren, LParenLoc);
 
   return Owned(Actions.ParseObjCProtocolExpression(protocolId, AtLoc, ProtoLoc,
@@ -2306,7 +2788,16 @@
 ///     objc-selector-expression
 ///       @selector '(' objc-keyword-selector ')'
 ExprResult Parser::ParseObjCSelectorExpression(SourceLocation AtLoc) {
-  SourceLocation SelectorLoc = ConsumeToken();
+  SourceLocation SelectorLoc;
+  tok::TokenKind r_token_kind;
+  if (!getLang().Eero || !Tok.is(tok::pipe)) { 
+    SelectorLoc = ConsumeToken();
+    r_token_kind = tok::r_paren;
+  } else {
+    SelectorLoc = Tok.getLocation();
+    Tok.setKind(tok::l_paren); // make parens for approp newline rules
+    r_token_kind = tok::pipe;
+  }
 
   if (Tok.isNot(tok::l_paren))
     return ExprError(Diag(Tok, diag::err_expected_lparen_after) << "@selector");
@@ -2319,7 +2810,7 @@
     Actions.CodeCompleteObjCSelector(getCurScope(), KeyIdents.data(),
                                      KeyIdents.size());
     ConsumeCodeCompletionToken();
-    MatchRHSPunctuation(tok::r_paren, LParenLoc);
+    MatchRHSPunctuation(r_token_kind, LParenLoc);
     return ExprError();
   }
   
@@ -2330,7 +2821,7 @@
 
   KeyIdents.push_back(SelIdent);
   unsigned nColons = 0;
-  if (Tok.isNot(tok::r_paren)) {
+  if (Tok.isNot(r_token_kind)) {
     while (1) {
       if (Tok.is(tok::coloncolon)) { // Handle :: in C++.
         ++nColons;
@@ -2340,14 +2831,14 @@
 
       ++nColons;
       ConsumeToken(); // Eat the ':'.
-      if (Tok.is(tok::r_paren))
+      if (Tok.is(r_token_kind))
         break;
       
       if (Tok.is(tok::code_completion)) {
         Actions.CodeCompleteObjCSelector(getCurScope(), KeyIdents.data(),
                                          KeyIdents.size());
         ConsumeCodeCompletionToken();
-        MatchRHSPunctuation(tok::r_paren, LParenLoc);
+        MatchRHSPunctuation(r_token_kind, LParenLoc);
         return ExprError();
       }
 
@@ -2359,8 +2850,33 @@
         break;
     }
   }
+  if (getLang().Eero && (r_token_kind == tok::pipe)) {
+    if (Tok.is(tok::pipe)) {
+      Tok.setKind(tok::r_paren); // make parens for approp newline rules
+    } else {
+      Diag(Tok, diag::err_expected_pipe);
+      return ExprError(Diag(LParenLoc, diag::note_matching) << "|");
+    }
+  }
   SourceLocation RParenLoc = MatchRHSPunctuation(tok::r_paren, LParenLoc);
   Selector Sel = PP.getSelectorTable().getSelector(nColons, &KeyIdents[0]);
   return Owned(Actions.ParseObjCSelectorExpression(Sel, AtLoc, SelectorLoc,
                                                    LParenLoc, RParenLoc));
  }
+
+/// \brief Parse Eero "typedef XX... ..." namespace-like prefixes.
+///
+ExprResult
+Parser::ParsePrefixTypedef(SourceLocation TypedefLoc) {
+  IdentifierInfo* prefixIdentInfo = Tok.getIdentifierInfo();
+  SourceLocation prefixLoc = ConsumeToken();
+  ConsumeToken(); // ellipsis
+  ConsumeToken(); // ellipsis
+
+  Actions.ActOnPrefixTypedef(getCurScope(),
+                             TypedefLoc,
+                             prefixLoc,
+                             prefixIdentInfo);
+  return ExprEmpty();
+}
+
Index: lib/Parse/ParseExpr.cpp
===================================================================
--- lib/Parse/ParseExpr.cpp	(revision 129311)
+++ lib/Parse/ParseExpr.cpp	(working copy)
@@ -223,6 +223,7 @@
     return ParseThrowExpression();
 
   ExprResult LHS(ParseCastExpression(false));
+  LHS = ParseRangeIfPresent(LHS);
   return ParseRHSOfBinaryExpression(move(LHS), prec::Assignment);
 }
 
@@ -274,6 +275,14 @@
     if (NextTokPrec < MinPrec)
       return move(LHS);
 
+    // Catches cases where the next line looks like the RHS of a bin op,
+    // but it really isn't, e.g. after some (non-decl) assignments.
+    if (getLang().Eero &&
+        Tok.isAtStartOfLine() && 
+        (ParenCount == 0) && (BracketCount == 0)) {
+      return move(LHS);
+    }
+
     // Consume the operator, saving the operator token for error reporting.
     Token OpToken = Tok;
     ConsumeToken();
@@ -294,6 +303,10 @@
           LHS = ExprError();
           TernaryMiddle = 0;
         }
+        // Eero uses 'else' keyword instead of colon here
+        if (getLang().Eero && Tok.is(tok::kw_else)) {
+          Tok.setKind(tok::colon);
+        }
       } else {
         // Special case handling of "X ? Y : Z" where Y is empty:
         //   logical-OR-expression '?' ':' conditional-expression   [GNU]
@@ -422,8 +435,12 @@
                                        isAddressOfOperand,
                                        NotCastExpr,
                                        TypeOfCast);
-  if (NotCastExpr)
+  if (NotCastExpr) {
     Diag(Tok, diag::err_expected_expression);
+    if (getLang().Eero) {
+      ConsumeAnyToken(); // extra cleanup after error to avoid getting "stuck"
+    }
+  }
   return move(Res);
 }
 
@@ -634,6 +651,32 @@
     // Consume the identifier so that we can see if it is followed by a '(' or
     // '.'.
     IdentifierInfo &II = *Tok.getIdentifierInfo();
+
+    if (getLang().Eero) {
+      // Eero does not require '@' for objc keywords
+      if (Tok.getObjCKeywordID() != tok::objc_not_keyword) {
+        return ParseObjCAtExpression(Tok.getLocation());
+      }
+      // Look for super or class message send. Also handle code completion.
+      if ((NextToken().is(tok::identifier) || 
+           (NextToken().is(tok::colon) && !InMessageExpression) ||
+           NextToken().is(tok::code_completion)) &&
+          (!NextToken().isAtStartOfLine() || ParenCount > 0 || BracketCount > 0)) {
+        ParsedType Typ;
+        if ((&II == Ident_super && getCurScope()->isInObjcMethodScope()) ||
+            ((Typ = Actions.getTypeName(II, Tok.getLocation(), getCurScope())) &&
+             Typ.get()->isObjCObjectOrInterfaceType())) {
+          if (NextToken().is(tok::colon)) {
+            Token SavedToken = Tok;
+            ConsumeToken(); // the identifier
+            Tok = SavedToken; // replace colon with identifier
+          }
+          Res = ParseObjCMessageExpression();
+          break;
+        }
+      }
+    }
+
     SourceLocation ILoc = ConsumeToken();
     
     // Support 'Class.property' and 'super.property' notation.
@@ -660,6 +703,7 @@
     // that identifier, this is probably a message send with a missing open
     // bracket. Treat it as such. 
     if (getLang().ObjC1 && &II == Ident_super && !InMessageExpression &&
+        !getLang().Eero &&
         getCurScope()->isInObjcMethodScope() &&
         ((Tok.is(tok::identifier) &&
          (NextToken().is(tok::colon) || NextToken().is(tok::r_square))) ||
@@ -675,6 +719,7 @@
     // appropriately. Also take this path if we're performing code
     // completion after an Objective-C class name.
     if (getLang().ObjC1 && 
+        !getLang().Eero &&
         ((Tok.is(tok::identifier) && !InMessageExpression) || 
          Tok.is(tok::code_completion))) {
       const Token& Next = NextToken();
@@ -715,9 +760,23 @@
     Name.setIdentifier(&II, ILoc);
     Res = Actions.ActOnIdExpression(getCurScope(), ScopeSpec, Name, 
                                     Tok.is(tok::l_paren), isAddressOfOperand);
+
+    // Otherwise, for Eero, <identifier> <identifier> means an 
+    // object message send.
+    if (getLang().Eero && 
+        Tok.is(tok::identifier) &&
+        (!Tok.isAtStartOfLine() || ParenCount > 0 || BracketCount > 0)) {
+      Res = ParseObjCMessageExpressionBody(ILoc, SourceLocation(), ParsedType(), 
+                                           Res.take());
+    }
+
     break;
   }
   case tok::char_constant:     // constant: character-constant
+    if (getLang().Eero && !InSystemHeader(Tok.getLocation())) {
+      Tok.setKind(tok::string_literal);
+      return ParseObjCAtExpression(Tok.getLocation());   
+    }
     Res = Actions.ActOnCharacterConstant(Tok);
     ConsumeToken();
     break;
@@ -1012,9 +1071,21 @@
     ConsumeCodeCompletionToken();
     return ParseCastExpression(isUnaryExpression, isAddressOfOperand, 
                                NotCastExpr, TypeOfCast);
+  case tok::pipe:
+    if (getLang().Eero)
+      return ParseObjCSelectorExpression(Tok.getLocation());
+  case tok::less:
+    if (getLang().Eero)
+      return ParseObjCProtocolExpression(Tok.getLocation());
+  case tok::kw_typedef: // should only get here with Eero "typedef XX... ..."
+    if (getLang().Eero)
+      return ParsePrefixTypedef(ConsumeToken());
+    NotCastExpr = true;
+    return ExprError();
+
   case tok::l_square:
     // These can be followed by postfix-expr pieces.
-    if (getLang().ObjC1)
+    if (getLang().ObjC1 && (!getLang().Eero || InSystemHeader(PrevTokLocation)))
       return ParsePostfixExpressionSuffix(ParseObjCMessageExpression());
     // FALL THROUGH.      
   default:
@@ -1050,6 +1121,13 @@
   // parsed, see if there are any postfix-expression pieces here.
   SourceLocation Loc;
   while (1) {
+
+    if (getLang().Eero && 
+        Tok.isAtStartOfLine() && 
+        (ParenCount == 0) && (BracketCount == 0)) {
+      return move(LHS);
+    }
+
     switch (Tok.getKind()) {
     case tok::code_completion:
       if (InMessageExpression)
@@ -1060,11 +1138,26 @@
       LHS = ExprError();
       break;
         
+
+    case tok::colon:
+      // Eero supports message passing via the colon operator.
+      if (getLang().Eero && !LHS.isInvalid() &&
+          !InMessageExpression &&
+          (!Tok.isAtStartOfLine() || (ParenCount > 0) || (BracketCount > 0)) &&
+          !InSystemHeader(PrevTokLocation)) {
+        ConsumeToken(); // consume the ":"
+        LHS = ParseObjCMessageExpressionBody(Tok.getLocation(), SourceLocation(),
+                                               ParsedType(), LHS.get());
+        break;
+      }
+      // falls through to default case for non-Eero or bad LHS expression
+
     case tok::identifier:
       // If we see identifier: after an expression, and we're not already in a
       // message send, then this is probably a message send with a missing
       // opening bracket '['.
       if (getLang().ObjC1 && !InMessageExpression && 
+          !getLang().Eero &&
           (NextToken().is(tok::colon) || NextToken().is(tok::r_square))) {
         LHS = ParseObjCMessageExpressionBody(SourceLocation(), SourceLocation(),
                                              ParsedType(), LHS.get());
@@ -1082,7 +1175,7 @@
       // actually another message send.  In this case, do some look-ahead to see
       // if the contents of the square brackets are obviously not a valid
       // expression and recover by pretending there is no suffix.
-      if (getLang().ObjC1 && Tok.isAtStartOfLine() &&
+      if (getLang().ObjC1 && Tok.isAtStartOfLine() && !getLang().Eero &&
           isSimpleObjCMessageExpression())
         return move(LHS);
           
@@ -1092,6 +1185,21 @@
       SourceLocation RLoc = Tok.getLocation();
 
       if (!LHS.isInvalid() && !Idx.isInvalid() && Tok.is(tok::r_square)) {
+        // Support Eero object "[]=" operator for integer indexes (arrays)
+        if (getLang().Eero && NextToken().is(tok::equal) && !InSystemHeader(Loc)) {
+          const QualType type = LHS.get()->getType();
+          if (!type.isNull() && type->isObjCObjectPointerType()) {
+            ConsumeBracket(); // Eat the "]"
+            SourceLocation ELoc = ConsumeToken(); // Eat the "="
+            ExprResult RHS(ParseCastExpression(false));
+            if (!RHS.isInvalid()) {
+              return Actions.ActOnObjectSubscriptAssignment(getCurScope(), 
+                                                            LHS.take(), Loc,
+                                                            Idx.take(), RLoc,
+                                                            RHS.take(), ELoc);
+            }
+          }
+        }
         LHS = Actions.ActOnArraySubscriptExpr(getCurScope(), LHS.take(), Loc,
                                               Idx.take(), RLoc);
       } else
@@ -1618,6 +1726,16 @@
     ConsumeCodeCompletionToken();
     return ExprError();
   }
+
+  // For Eero, if we have an identifier that is followed by an 
+  // identifier or a colon, then this is probably a message send.
+  if (getLang().Eero &&
+      Tok.is(tok::identifier) &&
+      (NextToken().is(tok::identifier) || NextToken().is(tok::colon))) {
+    ExprType = SimpleExpr;
+    TypeOfCast = ParsedType();
+  }
+
   
   if (ExprType >= CompoundStmt && Tok.is(tok::l_brace)) {
     Diag(Tok, diag::ext_gnu_statement_expr);
@@ -1684,6 +1802,14 @@
         // returns the parsed type to the callee.
         if (stopIfCastExpr)
           return ExprResult();
+
+        // Eero requires expr to cast on same line (unless in parens/braces)
+        if (getLang().Eero && 
+            Tok.isAtStartOfLine() &&
+            (ParenCount == 0) && (BracketCount == 0)) {
+          Diag(RParenLoc, diag::err_expected_expression_after) << ")";
+          return ExprError();
+        }
         
         // Reject the cast of super idiom in ObjC.
         if (Tok.is(tok::identifier) && getLang().ObjC1 &&
@@ -1889,7 +2015,7 @@
 
   // If this block has arguments, parse them.  There is no ambiguity here with
   // the expression case, because the expression case requires a parameter list.
-  if (Tok.is(tok::l_paren)) {
+  if (Tok.is(tok::l_paren) && (!getLang().Eero || !Tok.isAtStartOfLine())) {
     ParseParenDeclarator(ParamInfo);
     // Parse the pieces after the identifier as if we had "int(...)".
     // SetIdentifier sets the source range end, but in this case we're past
@@ -1909,7 +2035,8 @@
 
     // Inform sema that we are starting a block.
     Actions.ActOnBlockArguments(ParamInfo, getCurScope());
-  } else if (!Tok.is(tok::l_brace)) {
+  } else if (!Tok.is(tok::l_brace) && 
+             (!getLang().Eero || !Tok.isAtStartOfLine())) {
     ParseBlockId();
   } else {
     // Otherwise, pretend we saw (void).
@@ -1930,16 +2057,58 @@
     Actions.ActOnBlockArguments(ParamInfo, getCurScope());
   }
 
+  // Eero supports blocks with an inline single expression or a
+  // single return statement. e.g. "^(int x | return x)"
 
+  enum InlineType { NotInline=0, InlineReturn, InlineExpr };
+  InlineType inlineType;
+  SourceLocation ReturnLoc;
+
+  if (getLang().Eero) {
+    inlineType = NotInline;
+    if (Tok.isAtStartOfLine()) {  // a newline, so an indented block is
+      InsertToken(tok::l_brace);  // expected
+    } else if (Tok.is(tok::pipe)) {
+      if (Tok.getLength() == 0) { // only accept an inserted pipe
+        ConsumeToken(); // eat the "|"
+        if (Tok.is(tok::kw_return)) {
+          inlineType = InlineReturn;
+          ReturnLoc = ConsumeToken();  // consume the "return"
+        } else {
+          inlineType = InlineExpr;
+        }
+      }
+    } else {
+      Diag(Tok, diag::err_expected_newline);
+      Diag(CaretLoc, diag::note_using);
+    }
+  }
+
   ExprResult Result(true);
-  if (!Tok.is(tok::l_brace)) {
+  if (!Tok.is(tok::l_brace) && (!getLang().Eero || !inlineType)) {
     // Saw something like: ^expr
     Diag(Tok, diag::err_expected_expression);
     Actions.ActOnBlockError(CaretLoc, getCurScope());
     return ExprError();
   }
 
-  StmtResult Stmt(ParseCompoundStatementBody());
+  StmtResult Stmt;
+  if (!getLang().Eero || !inlineType) {
+    Stmt = ParseCompoundStatementBody();
+  } else {
+    bool SavedInMessageFlag = InMessageExpression; // find better way to
+    InMessageExpression = false;                   // do this
+    ExprResult Res (ParseAssignmentExpression()); // no comma operators
+    InMessageExpression = SavedInMessageFlag;
+    if (Res.isInvalid())
+      Stmt = StmtError();
+    else if (inlineType == InlineReturn)
+      Stmt = Actions.ActOnReturnStmt(ReturnLoc, Res.take());
+    else
+      Stmt = StmtResult(Res.take());
+    MatchRHSPunctuation(tok::r_paren, ParamInfo.getSourceRange().getBegin());
+  }
+
   BlockScope.Exit();
   if (!Stmt.isInvalid())
     Result = Actions.ActOnBlockStmtExpr(CaretLoc, Stmt.take(), getCurScope());
@@ -1947,3 +2116,104 @@
     Actions.ActOnBlockError(CaretLoc, getCurScope());
   return move(Result);
 }
+
+/// Eero: parse expression 'left ... right' as an NSRange compound
+/// literal expression: (NSRange){ left, (right - left) + 1 }
+///
+ExprResult Parser::ParseRangeIfPresent(ExprResult LHS) {
+
+  if (getLang().Eero && Tok.is(tok::ellipsis) &&
+      (!Tok.isAtStartOfLine() || ParenCount > 0 || BracketCount > 0)) {
+
+    // Make sure type NSRange is defined. If not, skip all this and ignore
+    // this notation.
+    ParsedType RangeType = 
+        Actions.getTypeName(PP.getIdentifierTable().getOwn("NSRange"), 
+                            Tok.getLocation(), 
+                            getCurScope());
+    if (!RangeType.get().isNull()) {
+      // Make sure LHS is an integer type
+      const QualType ltype = LHS.get()->getType();
+      if (!ltype.isNull() && 
+          ltype->isIntegerType() &&
+          !ltype->isStrictEnumeralType()) {
+
+        SourceLocation EllipsisLoc = ConsumeToken(); // the "..."
+
+        ExprResult RHS(ParseCastExpression(false));
+        const QualType rtype = RHS.get()->getType();
+
+        // Make sure RHS is an integer type
+        if (!rtype.isNull() && 
+            rtype->isIntegerType() &&
+            !rtype->isStrictEnumeralType()) {
+
+          SourceLocation LLoc = LHS.get()->getLocStart();
+          SourceLocation RLoc = RHS.get()->getLocEnd();
+
+          // If constant expressions, make sure neither left nor right are 
+          // negative. This is actually better checking than what NSMakeRange 
+          // or a compound literal initializer gets us.
+          llvm::APSInt lValue;
+          llvm::APSInt rValue;
+          if (LHS.get()->isIntegerConstantExpr(lValue, Actions.Context) &&
+              lValue.isSigned() && lValue.isNegative())
+            // Report as error, but keep going
+            Diag(LHS.get()->getLocStart(), diag::err_expected) << 
+                 "unsigned expression" << LHS.get()->getSourceRange();
+          if (RHS.get()->isIntegerConstantExpr(rValue, Actions.Context) &&
+              rValue.isSigned() && rValue.isNegative()) {
+            // Report as error, but keep going
+            Diag(RHS.get()->getLocStart(), diag::err_expected) << 
+                 "unsigned expression" << RHS.get()->getSourceRange();
+          }
+
+          // Compute length from (right - left) + 1
+
+          ExprResult LengthExpr = 
+              Actions.ActOnBinOp(getCurScope(), EllipsisLoc,
+                                 tok::minus, 
+                                 RHS.get(), 
+                                 LHS.get());
+
+          Token One;
+          One.setKind(tok::numeric_constant);
+          One.setLiteralData("1");
+          One.setLength(1);
+          One.setLocation(EllipsisLoc);
+
+          ExprResult OneExpr = Actions.ActOnNumericConstant(One);
+
+          LengthExpr = 
+              Actions.ActOnBinOp(getCurScope(), EllipsisLoc,
+                                 tok::plus, 
+                                 LengthExpr.take(), 
+                                 OneExpr.take() );
+
+          // Build (NSRange){ location, length } compound literal expression
+
+          ExprVector InitExprs(Actions);
+          InitExprs.push_back(LHS.release());
+          InitExprs.push_back(LengthExpr.release());
+
+          ExprResult Result = 
+              Actions.ActOnInitList(LLoc, 
+                                    move_arg(InitExprs),
+                                    RLoc);
+          
+          LHS = Actions.ActOnCompoundLiteral(LLoc, 
+                                             RangeType, 
+                                             RLoc, 
+                                             Result.take());
+        } else {
+          return ExprError(Diag(RHS.get()->getLocStart(),
+                                diag::err_expected) << "integer" <<
+                                RHS.get()->getSourceRange());
+        }
+      }
+    }
+  }
+  return LHS;
+}
+
+
Index: lib/Parse/ParseStmt.cpp
===================================================================
--- lib/Parse/ParseStmt.cpp	(revision 129311)
+++ lib/Parse/ParseStmt.cpp	(working copy)
@@ -102,10 +102,17 @@
     return ParseStatementOrDeclaration(Stmts, OnlyStatement);
       
   case tok::identifier:
-    if (NextToken().is(tok::colon)) { // C99 6.8.1: labeled-statement
+    if (NextToken().is(tok::colon) && !getLang().Eero) { // C99 6.8.1: labeled-statement
       // identifier ':' statement
       return ParseLabeledStatement(attrs);
     }
+    if (getLang().Eero) {
+      // If an objc '@' keyword (without the '@')
+      if (Tok.getObjCKeywordID() != tok::objc_not_keyword) {
+        return ParseObjCAtStatement(Tok.getLocation());
+      }    
+      ParseColonEqualOperatorIfPresent();
+    }
     // PASS THROUGH.
 
   default: {
@@ -134,16 +141,33 @@
       return StmtError();
     }
     // Otherwise, eat the semicolon.
+    if (!getLang().Eero) {
     ExpectAndConsumeSemi(diag::err_expected_semi_after_expr);
+    } else if (Tok.is(tok::semi)) {
+      ConsumeToken();
+    }
     return Actions.ActOnExprStmt(Actions.MakeFullExpr(Expr.get()));
   }
 
   case tok::kw_case:                // C99 6.8.1: labeled-statement
+    if (getLang().Eero) { // auto-break all cases/defaults
+      Actions.ActOnBreakStmt(Tok.getLocation(), getCurScope());      
+    }
     return ParseCaseStatement(attrs);
   case tok::kw_default:             // C99 6.8.1: labeled-statement
+    if (getLang().Eero) { // auto-break all cases/defaults
+      Actions.ActOnBreakStmt(Tok.getLocation(), getCurScope());
+    }
     return ParseDefaultStatement(attrs);
 
   case tok::l_brace:                // C99 6.8.2: compound-statement
+    if (getLang().Eero && 
+        Tok.getLength() != 0 && // if not an inserted left brace
+        !InSystemHeader(Tok.getLocation())) {
+      Diag(Tok, diag::err_lbrace_not_allowed);
+      ConsumeAnyToken(); // eat it and move on
+      return StmtError();
+    }
     return ParseCompoundStatement(attrs);
   case tok::semi: {                 // C99 6.8.3p3: expression[opt] ';'
     bool LeadingEmptyMacro = Tok.hasLeadingEmptyMacro();
@@ -165,6 +189,11 @@
     return ParseForStatement(attrs);
 
   case tok::kw_goto:                // C99 6.8.6.1: goto-statement
+    if (getLang().Eero) { // goto still a keyword, but use is forbidden in Eero
+      Diag(Tok, diag::err_goto_statement_forbidden);
+      SkipUntil(tok::identifier);
+      return StmtError();
+    }      
     Res = ParseGotoStatement(attrs);
     SemiError = "goto";
     break;
@@ -198,7 +227,7 @@
   // If we reached this code, the statement must end in a semicolon.
   if (Tok.is(tok::semi)) {
     ConsumeToken();
-  } else if (!Res.isInvalid()) {
+  } else if (!Res.isInvalid() && !getLang().Eero) {
     // If the result was valid, then we do want to diagnose this.  Use
     // ExpectAndConsume to emit the diagnostic, even though we know it won't
     // succeed.
@@ -319,15 +348,22 @@
       ColonLoc = ConsumeToken();
 
     // Treat "case blah;" as a typo for "case blah:".
-    } else if (Tok.is(tok::semi)) {
+    } else if (!getLang().Eero && Tok.is(tok::semi)) {
       ColonLoc = ConsumeToken();
       Diag(ColonLoc, diag::err_expected_colon_after) << "'case'"
         << FixItHint::CreateReplacement(ColonLoc, ":");
-    } else {
+    } else if (!getLang().Eero) {
       SourceLocation ExpectedLoc = PP.getLocForEndOfToken(PrevTokLocation);
       Diag(ExpectedLoc, diag::err_expected_colon_after) << "'case'"
         << FixItHint::CreateInsertion(ExpectedLoc, ":");
       ColonLoc = ExpectedLoc;
+    } else { // Eero 
+      if (Tok.isAtStartOfLine()) {
+        InsertToken(tok::l_brace);  // create a new scope
+      } else if (Tok.isNot(tok::comma)) { // not a list of cases
+        Diag(Tok, diag::err_expected_comma);
+        Diag(CaseLoc, diag::note_using);
+      }
     }
     
     StmtResult Case =
@@ -352,7 +388,7 @@
     }
 
     // Handle all case statements.
-  } while (Tok.is(tok::kw_case));
+  } while (Tok.is(tok::kw_case) || (getLang().Eero && Tok.is(tok::comma)) );
 
   assert(!TopLevelCase.isInvalid() && "Should have parsed at least one case!");
 
@@ -396,15 +432,23 @@
     ColonLoc = ConsumeToken();
 
   // Treat "default;" as a typo for "default:".
-  } else if (Tok.is(tok::semi)) {
+  } else if (!getLang().Eero && Tok.is(tok::semi)) {
     ColonLoc = ConsumeToken();
     Diag(ColonLoc, diag::err_expected_colon_after) << "'default'"
       << FixItHint::CreateReplacement(ColonLoc, ":");
-  } else {
+  } else if (!getLang().Eero) {
     SourceLocation ExpectedLoc = PP.getLocForEndOfToken(PrevTokLocation);
     Diag(ExpectedLoc, diag::err_expected_colon_after) << "'default'"
       << FixItHint::CreateInsertion(ExpectedLoc, ":");
     ColonLoc = ExpectedLoc;
+
+  } else { // Eero 
+    if (Tok.isAtStartOfLine()) {
+      InsertToken(tok::l_brace);  // create a new scope
+    } else {
+      Diag(Tok, diag::err_expected_newline);
+      Diag(DefaultLoc, diag::note_using);
+    }
   }
   
   // Diagnose the common error "switch (X) {... default: }", which is not valid.
@@ -463,7 +507,19 @@
   return ParseCompoundStatementBody(isStmtExpr);
 }
 
+/// File-private helper function used for Eero to determine if an indentation level
+/// is valid (previously established) for the current scope.
+static bool IsValidIndentation( unsigned column, 
+                                const std::deque<unsigned>& indentationPositions) {
+  if (column < indentationPositions.back())
+    return true;
+  else
+    return ( find( indentationPositions.begin(), 
+                   indentationPositions.end(), 
+                   column ) != indentationPositions.end() );
+}
 
+
 /// ParseCompoundStatementBody - Parse a sequence of statements and invoke the
 /// ActOnCompoundStmt action.  This expects the '{' to be the current token, and
 /// consume the '}' at the end of the block.  It does not manipulate the scope
@@ -480,7 +536,7 @@
 
   // "__label__ X, Y, Z;" is the GNU "Local Label" extension.  These are
   // only allowed at the start of a compound stmt regardless of the language.
-  while (Tok.is(tok::kw___label__)) {
+  while (Tok.is(tok::kw___label__) && !getLang().Eero) {
     SourceLocation LabelLoc = ConsumeToken();
     Diag(LabelLoc, diag::ext_gnu_local_label);
     
@@ -510,7 +566,32 @@
       Stmts.push_back(R.release());
   }
   
+  bool newScope(true); // Eero, for off-side rule support
+
   while (Tok.isNot(tok::r_brace) && Tok.isNot(tok::eof)) {
+
+    if (getLang().Eero && Tok.isAtStartOfLine() && !InSystemHeader(LBraceLoc)) {      
+      unsigned column = Column(Tok.getLocation());      
+      if (!indentationPositions.empty()) {
+        if ((newScope && column <= indentationPositions.front()) ||
+            (!newScope && column != indentationPositions.front())) {          
+          if (column < indentationPositions.front() && 
+              IsValidIndentation(column,indentationPositions)) {
+            InsertToken(tok::r_brace);
+            break;          
+          } else {
+            Diag(Tok, diag::err_ambiguous_indentation);
+            SkipUntil(tok::eof, false, true); // subsequent scopes likely off,
+            return StmtError();               // so abandon the rest of the file
+          }
+        }
+      }
+      if (newScope) {
+        newScope = false;
+        indentationPositions.push_front(column);
+      }
+    }    
+
     if (Tok.is(tok::annot_pragma_unused)) {
       HandlePragmaUnused();
       continue;
@@ -551,10 +632,14 @@
           continue;
         }
 
+        if (!getLang().Eero) {
         // FIXME: Use attributes?
         // Eat the semicolon at the end of stmt and convert the expr into a
         // statement.
         ExpectAndConsumeSemi(diag::err_expected_semi_after_expr);
+        } else if (Tok.is(tok::semi)) {
+          ConsumeToken();
+        }
         R = Actions.ActOnExprStmt(Actions.MakeFullExpr(Res.get()));
       }
     }
@@ -564,6 +649,15 @@
   }
 
   // We broke out of the while loop because we found a '}' or EOF.
+  if (getLang().Eero && !indentationPositions.empty()) {
+    indentationPositions.pop_front();
+
+    if (Tok.is(tok::eof)) { // exit compound body 
+      InsertToken(tok::r_brace);
+    } else if (Tok.getLength() != 0) { // if not an inserted right brace
+      Diag(Tok, diag::err_rbrace_not_allowed);
+    }
+  }
   if (Tok.isNot(tok::r_brace)) {
     Diag(Tok, diag::err_expected_rbrace);
     Diag(LBraceLoc, diag::note_matching) << "{";
@@ -590,7 +684,10 @@
                                        Decl *&DeclResult,
                                        SourceLocation Loc,
                                        bool ConvertToBoolean) {
-  SourceLocation LParenLoc = ConsumeParen();
+  SourceLocation LParenLoc;  
+  if (!getLang().Eero || InSystemHeader(Loc)) {
+    LParenLoc = ConsumeParen();
+  }
   if (getLang().CPlusPlus) 
     ParseCXXCondition(ExprResult, DeclResult, Loc, ConvertToBoolean);
   else {
@@ -614,8 +711,10 @@
       return true;
   }
 
-  // Otherwise the condition is valid or the rparen is present.
-  MatchRHSPunctuation(tok::r_paren, LParenLoc);
+  if (LParenLoc.isValid()) {
+    // Otherwise the condition is valid or the rparen is present.
+    MatchRHSPunctuation(tok::r_paren, LParenLoc);
+  }
   return false;
 }
 
@@ -633,7 +732,7 @@
   assert(Tok.is(tok::kw_if) && "Not an if stmt!");
   SourceLocation IfLoc = ConsumeToken();  // eat the 'if'.
 
-  if (Tok.isNot(tok::l_paren)) {
+  if (!getLang().Eero && Tok.isNot(tok::l_paren)) {
     Diag(Tok, diag::err_expected_lparen_after) << "if";
     SkipUntil(tok::semi);
     return StmtError();
@@ -663,6 +762,16 @@
 
   FullExprArg FullCondExp(Actions.MakeFullExpr(CondExp.get()));
 
+  // It's easiest if we just inject the inferred left brace
+  if (getLang().Eero && !InSystemHeader(IfLoc)) {
+    if (Tok.isAtStartOfLine()) {
+      InsertToken(tok::l_brace);  // create a new scope
+    } else {
+      Diag(Tok, diag::err_expected_newline);
+      Diag(IfLoc, diag::note_using);
+    }
+  }
+
   // C99 6.8.4p3 - In C99, the body of the if statement is a scope, even if
   // there is no compound stmt.  C90 does not have this clause.  We only do this
   // if the body isn't a compound statement to avoid push/pop in common cases.
@@ -696,8 +805,32 @@
   SourceLocation ElseStmtLoc;
   StmtResult ElseStmt;
 
-  if (Tok.is(tok::kw_else)) {
+  // For Eero, looked for "else"s associated with previous "if"s. For other
+  // languages, process all of them.
+  bool ProcessElseStatement;
+  if (Tok.is(tok::kw_else) &&
+      (!getLang().Eero ||
+       Column(Tok.getLocation()) == indentationPositions.front() ||
+       InSystemHeader(IfLoc))) {
+    ProcessElseStatement = true;
+  } else {
+    ProcessElseStatement = false;
+  }
+
+  if (ProcessElseStatement) {
     ElseLoc = ConsumeToken();
+
+    // For Eero, if not an "if else" (on same line), inject a left brace
+    if (getLang().Eero && 
+        !(Tok.is(tok::kw_if) && !Tok.isAtStartOfLine()) &&
+        !InSystemHeader(IfLoc)) {
+      if (Tok.isAtStartOfLine()) {
+        InsertToken(tok::l_brace); // create a new scope
+      } else {
+        Diag(Tok, diag::err_expected_newline);
+        Diag(ElseLoc, diag::note_using);
+      }
+    }
     ElseStmtLoc = Tok.getLocation();
 
     // C99 6.8.4p3 - In C99, the body of the if statement is a scope, even if
@@ -755,7 +888,7 @@
   assert(Tok.is(tok::kw_switch) && "Not a switch stmt!");
   SourceLocation SwitchLoc = ConsumeToken();  // eat the 'switch'.
 
-  if (Tok.isNot(tok::l_paren)) {
+  if (!getLang().Eero && Tok.isNot(tok::l_paren)) {
     Diag(Tok, diag::err_expected_lparen_after) << "switch";
     SkipUntil(tok::semi);
     return StmtError();
@@ -801,7 +934,17 @@
       SkipUntil(tok::semi);
     return move(Switch);
   }
-  
+
+  // It's easiest if we just inject the inferred left brace
+  if (getLang().Eero && !InSystemHeader(SwitchLoc)) {
+    if (Tok.isAtStartOfLine()) {
+      InsertToken(tok::l_brace);
+    } else {
+      Diag(Tok, diag::err_expected_newline);
+      Diag(SwitchLoc, diag::note_using);
+    }
+  }
+
   // C99 6.8.4p3 - In C99, the body of the switch statement is a scope, even if
   // there is no compound stmt.  C90 does not have this clause.  We only do this
   // if the body isn't a compound statement to avoid push/pop in common cases.
@@ -841,7 +984,7 @@
   SourceLocation WhileLoc = Tok.getLocation();
   ConsumeToken();  // eat the 'while'.
 
-  if (Tok.isNot(tok::l_paren)) {
+  if (!getLang().Eero && Tok.isNot(tok::l_paren)) {
     Diag(Tok, diag::err_expected_lparen_after) << "while";
     SkipUntil(tok::semi);
     return StmtError();
@@ -877,6 +1020,16 @@
 
   FullExprArg FullCond(Actions.MakeFullExpr(Cond.get()));
 
+  // It's easiest if we just inject the inferred left brace
+  if (getLang().Eero && !InSystemHeader(WhileLoc)) {
+    if (Tok.isAtStartOfLine()) {
+      InsertToken(tok::l_brace);  // create a new scope
+    } else {
+      Diag(Tok, diag::err_expected_newline);
+      Diag(WhileLoc, diag::note_using);
+    }
+  }
+
   // C99 6.8.5p5 - In C99, the body of the if statement is a scope, even if
   // there is no compound stmt.  C90 does not have this clause.  We only do this
   // if the body isn't a compound statement to avoid push/pop in common cases.
@@ -924,6 +1077,16 @@
 
   ParseScope DoScope(this, ScopeFlags);
 
+  // It's easiest if we just inject the inferred left brace
+  if (getLang().Eero && !InSystemHeader(DoLoc)) {
+    if (Tok.isAtStartOfLine()) {
+      InsertToken(tok::l_brace);  // create a new scope
+    } else {
+      Diag(Tok, diag::err_expected_newline);
+      Diag(DoLoc, diag::note_using);
+    }
+  }
+
   // C99 6.8.5p5 - In C99, the body of the if statement is a scope, even if
   // there is no compound stmt.  C90 does not have this clause. We only do this
   // if the body isn't a compound statement to avoid push/pop in common cases.
@@ -952,16 +1115,22 @@
   }
   SourceLocation WhileLoc = ConsumeToken();
 
-  if (Tok.isNot(tok::l_paren)) {
+  if (!getLang().Eero && Tok.isNot(tok::l_paren)) {
     Diag(Tok, diag::err_expected_lparen_after) << "do/while";
     SkipUntil(tok::semi, false, true);
     return StmtError();
   }
 
   // Parse the parenthesized condition.
-  SourceLocation LPLoc = ConsumeParen();
+  SourceLocation LPLoc;
+  if (!getLang().Eero || Tok.is(tok::l_paren)) {
+    LPLoc = ConsumeParen();
+  }
   ExprResult Cond = ParseExpression();
-  SourceLocation RPLoc = MatchRHSPunctuation(tok::r_paren, LPLoc);
+  SourceLocation RPLoc;
+  if (!getLang().Eero || LPLoc.isValid()) {
+    RPLoc = MatchRHSPunctuation(tok::r_paren, LPLoc);
+  }
   DoScope.Exit();
 
   if (Cond.isInvalid() || Body.isInvalid())
@@ -990,7 +1159,7 @@
   assert(Tok.is(tok::kw_for) && "Not a for stmt!");
   SourceLocation ForLoc = ConsumeToken();  // eat the 'for'.
 
-  if (Tok.isNot(tok::l_paren)) {
+  if (!getLang().Eero && Tok.isNot(tok::l_paren)) {
     Diag(Tok, diag::err_expected_lparen_after) << "for";
     SkipUntil(tok::semi);
     return StmtError();
@@ -1022,7 +1191,10 @@
 
   ParseScope ForScope(this, ScopeFlags);
 
-  SourceLocation LParenLoc = ConsumeParen();
+  SourceLocation LParenLoc;  
+  if (!getLang().Eero || Tok.is(tok::l_paren)) {
+    LParenLoc = ConsumeParen();
+  }
   ExprResult Value;
 
   bool ForEach = false;
@@ -1032,6 +1204,8 @@
   ExprResult Collection;
   FullExprArg ThirdPart(Actions);
   Decl *SecondVar = 0;
+  TypeResult StrictEnumType = TypeResult(true); // Eero
+  ExprResult StrictEnumRangeEnd(true);          //
   
   if (Tok.is(tok::code_completion)) {
     Actions.CodeCompleteOrdinaryName(getCurScope(), 
@@ -1065,16 +1239,35 @@
       // ObjC: for (id x in expr)
       ConsumeToken(); // consume 'in'
       
+      // Eero supports strict enum types for the "in" range
+      if (getLang().Eero && isTypeSpecifierQualifier()) { 
+        StrictEnumType = ParseTypeName();
+        if (StrictEnumType.isInvalid()) {
+          Diag(Tok, diag::err_expected_type_name_after_typename);
+          return StmtError(Diag(Tok, diag::err_expected_type));
+        }
+      } else { // TODO: block below shifted left for better patching
       if (Tok.is(tok::code_completion)) {
         Actions.CodeCompleteObjCForCollection(getCurScope(), DG);
         ConsumeCodeCompletionToken();
       }
       Collection = ParseExpression();
+      }
     } else {
       Diag(Tok, diag::err_expected_semi_for);
     }
   } else {
+    bool SemicolonInserted = false;
+    if (getLang().Eero && NextToken().is(tok::identifier)) {
+      Token tempSemicolon(Tok);
+      tempSemicolon.setKind(tok::semi);
+      PP.EnterToken(tempSemicolon);
+      SemicolonInserted = true;
+    }
     Value = ParseExpression();
+    if (SemicolonInserted)
+      ConsumeToken(); // consume temp inserted semicolon
+    
 
     ForEach = isTokIdentifier_in();
 
@@ -1091,11 +1284,20 @@
     } else if (ForEach) {
       ConsumeToken(); // consume 'in'
       
+      // Eero supports strict enum types for the "in" range
+      if (getLang().Eero && isTypeSpecifierQualifier()) { 
+        StrictEnumType = ParseTypeName();
+        if (StrictEnumType.isInvalid()) {
+          Diag(Tok, diag::err_expected_type_name_after_typename);
+          return StmtError(Diag(Tok, diag::err_expected_type));
+        }
+      } else { // TODO: block below shifted left for better patching
       if (Tok.is(tok::code_completion)) {
         Actions.CodeCompleteObjCForCollection(getCurScope(), DeclGroupPtrTy());
         ConsumeCodeCompletionToken();
       }
       Collection = ParseExpression();
+      }
     } else {
       if (!Value.isInvalid()) {
         Diag(Tok, diag::err_expected_semi_for);
@@ -1147,8 +1349,27 @@
     }
   }
   // Match the ')'.
-  SourceLocation RParenLoc = MatchRHSPunctuation(tok::r_paren, LParenLoc);
+  SourceLocation RParenLoc;
+  if (LParenLoc.isValid()) {
+    RParenLoc = MatchRHSPunctuation(tok::r_paren, LParenLoc);
+  }
 
+  if (getLang().Eero && !InSystemHeader(ForLoc)) {
+    // Check for strict enum constant range
+    if (Tok.is(tok::ellipsis) && !Tok.isAtStartOfLine() &&
+        !Collection.isInvalid()) {
+        ConsumeToken(); // eat the "..."
+        StrictEnumRangeEnd = ParseCastExpression(false);
+    }
+    // It's easiest if we just inject the inferred left brace
+    if (Tok.isAtStartOfLine()) {
+      InsertToken(tok::l_brace);  // create a new scope
+    } else {
+      Diag(Tok, diag::err_expected_newline);
+      Diag(ForLoc, diag::note_using);
+    }
+  }
+
   // C99 6.8.5p5 - In C99, the body of the if statement is a scope, even if
   // there is no compound stmt.  C90 does not have this clause.  We only do this
   // if the body isn't a compound statement to avoid push/pop in common cases.
@@ -1178,7 +1399,44 @@
   if (!ForEach)
     return Actions.ActOnForStmt(ForLoc, LParenLoc, FirstPart.take(), SecondPart,
                                 SecondVar, ThirdPart, RParenLoc, Body.take());
+  if (getLang().Eero) {
+    // these all assume a first part
+    if (Value.isInvalid())
+      return StmtError();
 
+    // Check for a strict enum type name after the "in" (loop entire 
+    // range of enums)
+    if (!StrictEnumType.isInvalid()) {
+      return Actions.ActOnForStrictEnumStmt(ForLoc, 
+                                            FirstPart.take(), 
+                                            StrictEnumType.take(), 
+                                            Body.take());
+    }
+    // Check for strict enum value range after the "in"
+    if (!StrictEnumRangeEnd.isInvalid()) {
+      return Actions.ActOnForStrictEnumRangeStmt(ForLoc, 
+                                                 FirstPart.take(), 
+                                                 Collection.take(), 
+                                                 StrictEnumRangeEnd.take(), 
+                                                 Body.take());
+    }
+    // Check for an NSRange expression after the "in".    
+    // First make sure type NSRange is defined. If not, don't recognize
+    // NSRange for loops.
+    ParsedType RangeType = 
+        Actions.getTypeName(PP.getIdentifierTable().getOwn("NSRange"), 
+                            SourceLocation(),
+                            getCurScope());
+
+    if (!RangeType.get().isNull() && 
+        Collection.get()->getType() == RangeType.get()) {
+      return Actions.ActOnForRangeStmt(ForLoc, 
+                                       FirstPart.take(), 
+                                       Collection.take(), 
+                                       Body.take());
+    }
+  }
+
   // FIXME: It isn't clear how to communicate the late destruction of 
   // C++ temporaries used to create the collection.
   return Actions.ActOnObjCForCollectionStmt(ForLoc, LParenLoc, FirstPart.take(), 
@@ -1259,7 +1517,7 @@
   SourceLocation ReturnLoc = ConsumeToken();  // eat the 'return'.
 
   ExprResult R;
-  if (Tok.isNot(tok::semi)) {
+  if (Tok.isNot(tok::semi) && !(getLang().Eero && Tok.isAtStartOfLine())) {
     if (Tok.is(tok::code_completion)) {
       Actions.CodeCompleteReturn(getCurScope());
       ConsumeCodeCompletionToken();
@@ -1719,3 +1977,54 @@
 
   return Actions.ActOnCXXCatchBlock(CatchLoc, ExceptionDecl, Block.take());
 }
+
+/// Eero-specific support for ":=" operator.
+void Parser::ParseColonEqualOperatorIfPresent() {
+  // Note that Eero does not support gotos/labels.
+  if (!GetLookAheadToken(1).isAtStartOfLine() &&
+      !GetLookAheadToken(2).isAtStartOfLine()) {
+    if ((GetLookAheadToken(1).is(tok::identifier) && // declaration with initializer
+         GetLookAheadToken(2).is(tok::colon) &&      //
+         GetLookAheadToken(3).is(tok::equal) &&      //
+         !GetLookAheadToken(3).isAtStartOfLine() &&  //
+         !GetLookAheadToken(3).hasLeadingSpace()) || //
+        (GetLookAheadToken(1).is(tok::colon) &&      // object message with assignment
+         GetLookAheadToken(2).is(tok::equal) &&      //
+         !GetLookAheadToken(2).hasLeadingSpace())) { //
+      bool isDecl;
+      if (GetLookAheadToken(1).is(tok::identifier))
+        isDecl = true;
+      else
+        isDecl = false;
+
+      // Save off left-hand side
+      Token objectClass;
+      if (isDecl) {
+        objectClass = Tok;
+        ConsumeToken();
+      }
+      Token object = Tok;
+      ConsumeToken();
+      ConsumeToken(); // ":"
+      Token equals = Tok;
+      ConsumeToken(); // "="
+
+      // Modify right-hand side
+      Tok.clearFlag(Token::StartOfLine); // ignore any newlines after the ":="
+      PP.EnterToken(Tok); // push forward new current token
+      if (isDecl)
+        PP.EnterToken(objectClass);
+      else
+        PP.EnterToken(object);
+
+      // Restore left-hand side
+      PP.EnterToken(equals);
+      PP.EnterToken(object);
+      if (isDecl)
+        PP.EnterToken(objectClass);          
+      ConsumeAnyToken(); // remove token that was pushed forward earlier
+    }
+  }
+}
+
+
Index: lib/Parse/Parser.cpp
===================================================================
--- lib/Parse/Parser.cpp	(revision 129311)
+++ lib/Parse/Parser.cpp	(working copy)
@@ -139,6 +139,9 @@
   case tok::greater:  LHSName = "<"; DID = diag::err_expected_greater; break;
   case tok::greatergreatergreater:
                       LHSName = "<<<"; DID = diag::err_expected_ggg; break;
+  case tok::pipe: if (getLang().Eero) { 
+                    LHSName = "|"; DID = diag::err_expected_pipe;
+                    } break;
   }
   Diag(Tok, DID);
   Diag(LHSLoc, diag::note_matching) << LHSName;
@@ -243,6 +246,15 @@
         }
         return true;
       }
+      // For Eero searches on semicolon, skip to next statement in current block
+      if (getLang().Eero && Tok.isNot(tok::eof) &&
+          (StopAtSemi || Toks[i] == tok::semi) &&
+          !InSystemHeader(Tok.getLocation()) &&
+          Tok.isAtStartOfLine() && 
+          !indentationPositions.empty() &&
+          Column(Tok.getLocation()) <= indentationPositions.front()) {
+        return false;
+      }
     }
 
     switch (Tok.getKind()) {
@@ -549,6 +561,13 @@
   case tok::kw_using:
   case tok::kw_namespace:
   case tok::kw_typedef:
+    if (getLang().Eero && 
+        GetLookAheadToken(1).is(tok::identifier) && 
+        GetLookAheadToken(2).is(tok::ellipsis) && 
+        GetLookAheadToken(3).is(tok::ellipsis) ) {
+      ParsePrefixTypedef(ConsumeToken());
+      break;
+    }   
   case tok::kw_template:
   case tok::kw_export:    // As in 'export template'
   case tok::kw_static_assert:
@@ -608,6 +627,19 @@
 
   default:
   dont_know:
+    if (getLang().Eero && !InSystemHeader(Tok.getLocation())) {
+      // If an objc '@' keyword (without the '@')
+      if (Tok.getObjCKeywordID() != tok::objc_not_keyword) {
+        InsertToken(tok::at);
+        SingleDecl = ParseObjCAtDirectives();
+        break;
+      } else if (!PendingObjCImpDecl.empty() && // within interface or impl block
+                 (Tok.is(tok::identifier) ||    //   instance method
+                  Tok.is(tok::kw_static))) {    //   class method
+        SingleDecl = ParseObjCMethodDefinition();
+        break;
+      }
+    }
     // We can't tell whether this is a function-definition or declaration yet.
     if (DS) {
       DS->takeAttributesFrom(attrs);
@@ -638,6 +670,20 @@
 /// declarator, indicates the start of a function definition.
 bool Parser::isStartOfFunctionDefinition(const ParsingDeclarator &Declarator) {
   assert(Declarator.isFunctionDeclarator() && "Isn't a function declarator");
+  // Check for Eero function definition or declaration
+  if (getLang().Eero && !InSystemHeader(Tok.getLocation())) {
+    if (!Tok.isAtStartOfLine()) {
+      Diag(Tok, diag::err_expected_newline);
+      while (!Tok.isAtStartOfLine()) // flush the rest of the
+        ConsumeAnyToken();           // line
+    }
+    if (Column(Tok.getLocation()) >   // look for indentation
+        Column(Declarator.getSourceRange().getBegin())) {
+      return true;
+    } else {
+      return false;
+    }
+  }
   if (Tok.is(tok::l_brace))   // int X() {}
     return true;
   
@@ -747,6 +793,15 @@
                                       const ParsedTemplateInfo &TemplateInfo) {
   const DeclaratorChunk::FunctionTypeInfo &FTI = D.getFunctionTypeInfo();
 
+  // For Eero, it's easiest if we just inject the inferred left brace
+  if (getLang().Eero && !InSystemHeader(Tok.getLocation())) {
+    if (Tok.isAtStartOfLine()) {
+      InsertToken(tok::l_brace);
+    } else {
+      Diag(Tok, diag::err_expected_newline);
+    }
+  }
+
   // If this is C90 and the declspecs were completely missing, fudge in an
   // implicit int.  We do this here because this is the only place where
   // declaration-specifiers are completely optional in the grammar.
